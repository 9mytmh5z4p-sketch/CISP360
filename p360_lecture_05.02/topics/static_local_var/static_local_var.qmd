# Static Local Variables

How can a function remember information between calls without using global variables? Today we'll explore static local variables and their unique behavior.

::: notes
Total slides: 8

Consider including a diagram showing multiple function calls and how a variable persists between them.
:::

<!-- Slide 1 -->

---

## Review: Regular Local Variables

Regular local variables are created when a function is called and destroyed when the function exits. Each time the function runs, the variable starts fresh with no memory of previous calls.

```cpp
void counter() {
    int count = 0;
    count++;
    cout << count;  // always prints 1
}
```

::: notes
Consider a diagram showing the creation and destruction of a local variable across multiple function calls.
:::

<!-- Slide 2 -->

---

## What is a Static Local Variable?

A static local variable retains its value between function calls. It is initialized only once and persists for the entire program lifetime, but remains local to its function.

This gives us the persistence of a global variable with the scope protection of a local variable.

<!-- Slide 3 -->

---

## Syntax and Initialization

To declare a static local variable, use the `static` keyword before the type. The initialization expression is evaluated only once, during the first function call.

```cpp
void counter() {
    static int count = 0;  // initialized once
    count++;
    cout << count;  // prints 1, 2, 3, 4...
}
```

Subsequent calls skip the initialization entirely and use the existing value.

<!-- Slide 4 -->

---

## Lifetime vs. Scope

Static local variables have function scope but program lifetime. They can only be accessed within their function, but they exist for the entire duration of the program.

```cpp
void demo() {
    static int x = 10;
    x += 5;
}

int main() {
    demo();  // x becomes 15
    demo();  // x becomes 20
    // cout << x;  // error: x not accessible here
}
```

::: notes
Consider a timeline diagram showing the variable existing throughout program execution but only accessible during function calls.
:::

<!-- Slide 5 -->

---

## Example: Function Call Counter

Static local variables are ideal for tracking how many times a function has been called.

```cpp
void trackCalls() {
    static int callCount = 0;
    callCount++;
    cout << "Called " << callCount << " times\n";
}

int main() {
    trackCalls();  // Called 1 times
    trackCalls();  // Called 2 times
    trackCalls();  // Called 3 times
}
```

<!-- Slide 6 -->

---

## Use Cases for Static Local Variables

Use static local variables for function call counters to track usage without polluting global scope. They keep the counter encapsulated within the function.

Use them for caching computed values to avoid recalculating expensive operations. For example, a function that computes factorials can store the last result and reuse it if called with the same input.

<!-- Slide 7 -->

---

## Summary

Static local variables persist between function calls while maintaining local scope. They combine the longevity of global variables with the encapsulation benefits of local variables.

<!-- Slide 8 -->