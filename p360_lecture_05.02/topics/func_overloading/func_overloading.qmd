# Function Overloading

## What if you need different versions<br> of the same operation?

In C++, you can define multiple functions with the same name as long as they have different parameter lists. This feature, called **function overloading**, allows you to create intuitive interfaces where related operations share a common name.

::: notes
Total slides in this section: 11

Function overloading is a form of compile-time polymorphism that makes code more readable and maintainable. Students should already be comfortable with function declarations, parameters, and return types before this section.
:::

<!-- Slide 1 -->

## What is Function Overloading?

**Function overloading** allows you to define multiple functions with the same name but different parameter lists. The compiler distinguishes between these functions based on the arguments provided when the function is called.

```cpp
int max(int a, int b);
double max(double a, double b);
int max(int a, int b, int c);
```

All three functions are named `max`, but each has a unique parameter list. The compiler selects the appropriate version based on the arguments you provide.

<!-- Slide 2 -->

## Function Signatures

The **function signature** consists of the function name and its parameter list (the number and types of parameters). Two functions have different signatures if they differ in the number of parameters, the types of parameters, or both.

```cpp
void print(int value);           // Signature: print(int)
void print(double value);        // Signature: print(double)
void print(int a, int b);        // Signature: print(int, int)
```

The signature does NOT include the return type or parameter names - only the parameter types and count matter for distinguishing overloaded functions.

::: notes
A visual diagram would be helpful here showing the components of a function signature. Show the function name and parameter types highlighted, with return type and parameter names grayed out to emphasize they're not part of the signature. Emphasize that understanding signatures is fundamental to understanding how overloading works - the compiler uses only the signature to distinguish between functions.
:::

<!-- Slide 3 -->

## Overloading by Number of Parameters

You can overload functions by providing different numbers of parameters.

```cpp
double calculateArea(double side) {
    return side * side;                    // Square
}

double calculateArea(double length, double width) {
    return length * width;                 // Rectangle
}

double calculateArea(double a, double b, double c) {
    // Triangle using Heron's formula
    double s = (a + b + c) / 2;
    return sqrt(s * (s - a) * (s - b) * (s - c));
}
```

Each version calculates area for a different shape based on how many parameters are provided.

::: notes
Emphasize that the function name suggests a common operation (calculating area) but the implementation differs based on the number of parameters. This makes the API intuitive - users don't need to remember different function names for related operations. The triangle version uses all three side lengths, making it a natural three-parameter overload.
:::

<!-- Slide 4 -->

## Overloading by Parameter Types

You can overload functions by using different parameter types, even with the same number of parameters.

```cpp
void display(int value) {
    cout << "Integer: " << value << endl;
}

void display(double value) {
    cout << "Double: " << value << endl;
}

void display(string value) {
    cout << "String: " << value << endl;
}
```

The compiler chooses the correct version based on the type of argument passed.

<!-- Slide 5 -->

## Combining Both Techniques

Functions can be overloaded by both the number and types of parameters simultaneously.

```cpp
int sum(int a, int b) {
    return a + b;
}

double sum(double a, double b) {
    return a + b;
}

int sum(int a, int b, int c) {
    return a + b + c;
}
```

This creates a flexible family of related functions that handle different scenarios.

::: notes
Point out that we have overloading by type (int vs. double with two parameters) and by number (two parameters vs. three parameters). This demonstrates that you can mix both techniques to create a comprehensive set of overloads. Students might ask why not also have a three-parameter double version - explain that you add overloads as needed, not exhaustively for every possible combination.
:::

<!-- Slide 6 -->

## Return Type is Not Enough

Two functions cannot be overloaded if they differ only in return type. The parameter list must be different.

**Invalid overloading:**
```cpp
int getValue();
double getValue();       // ERROR: conflicts with int getValue()
```

**Valid overloading:**
```cpp
int getValue(int x);
double getValue(double x);   // OK: different parameter types
```

The compiler determines which function to call based on the arguments at the call site, not on how you use the return value, so return type alone cannot distinguish functions.

::: notes
Explain why this makes sense: when you write getValue(), the compiler has no way to know which version you want based solely on what you do with the result later. Consider: int x = getValue(); - both versions could work here. The decision must be made at the call site based on the arguments provided, before the compiler even knows what you'll do with the return value.
:::

<!-- Slide 7 -->

## How the Compiler Chooses

When you call an overloaded function, the compiler follows a process called **overload resolution** to determine which version to use.

The compiler examines the arguments you provide and compares them against all available overloaded versions. It selects the function whose parameters best match the types and number of arguments supplied.

```cpp
void process(int x);
void process(double x);

process(5);        // Calls process(int)
process(5.0);      // Calls process(double)
```

If the compiler cannot determine a single best match (ambiguity), it generates a compiler error rather than guessing.

::: notes
Overload resolution is complex, but at this level students need to understand the basic principle: the compiler picks the best match based on the arguments. A flowchart showing the decision process would be helpful. Mention that ambiguity errors occur when two or more overloads are equally good matches - the compiler won't arbitrarily choose one.
:::

<!-- Slide 8 -->

## Exact Match Priority

The compiler prefers exact matches over conversions. If an exact match exists, it will be chosen.

```cpp
void show(int x) {
    cout << "int version" << endl;
}

void show(double x) {
    cout << "double version" << endl;
}

int main() {
    show(10);      // Exact match with int version
    show(10.5);    // Exact match with double version
    show(10.0);    // Exact match with double version
    return 0;
}
```

If no exact match exists, the compiler considers type conversions. For example, if only `show(double)` existed, calling `show(10)` would still work by converting the int to double.

::: notes
Students should understand that 10 is an int literal, 10.5 and 10.0 are double literals. The compiler doesn't need to convert anything when there's an exact match. If only show(double) existed, calling show(10) would work through automatic conversion, but it's not the best match if show(int) is available. Exact matches are always preferred to avoid unnecessary conversions.
:::

<!-- Slide 9 -->

## Practical Example

Function overloading is commonly used for operations that logically do the same thing but work with different data types or quantities.

```cpp
void printReport(string title, int value) {
    cout << title << ": " << value << endl;
}

void printReport(string title, double value) {
    cout << title << ": " << value << endl;
}

void printReport(string title, int value1, int value2) {
    cout << title << ": " << value1 << ", " << value2 << endl;
}

int main() {
    printReport("Count", 42);
    printReport("Average", 87.5);
    printReport("Range", 10, 100);
    return 0;
}
```

This provides a consistent interface for printing different types of reports.

::: notes
Emphasize that from the caller's perspective, printReport is a single conceptual operation - reporting a value. The overloading handles the details of different types and formats automatically. This is cleaner than having printReportInt, printReportDouble, printReportRange, etc. Point out how the three calls look similar and intuitive despite calling different underlying functions.
:::

<!-- Slide 10 -->

## Summary

Function overloading allows multiple functions to share the same name as long as their signatures (number and/or types of parameters) differ. The compiler automatically selects the correct version based on the arguments provided at the call site.

<!-- Slide 11 -->