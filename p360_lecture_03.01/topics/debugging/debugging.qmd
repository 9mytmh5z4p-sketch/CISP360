# Introduction to<br> Debugging in C++

::: notes
Target duration: ~30 minutes
:::

## Ever written code that worked <br> perfectly on the first try?

Neither has anyone else. Debugging is the process of finding and fixing errors in your code, and every programmer—from beginners to experts—does it constantly. The difference is that experienced programmers know how to find and fix bugs efficiently.

::: notes
Set the stage by normalizing bugs and emphasizing that debugging is a learnable skill, not a sign of failure.
:::

## Understanding Compiler Errors

When code won't compile, the compiler provides error messages to help you locate problems.

**How to read error messages:**
- **Line number** - Where the problem is (or near it)
- **Error type** - What kind of error occurred
- **Description** - What's wrong with the code

**Important:** The actual error might be on the line before the line number shown.

::: notes
Show students an actual compiler error message on screen and point out each component. Emphasize that error messages are trying to help, not punish. Consider displaying a diagram showing how to parse a typical error message like "main.cpp:15:5: error: expected ';' before 'cout'".
:::

## Common Error: Missing Semicolon

**Broken code:**
```cpp
int age = 25  // Missing semicolon
cout << age << endl;
```

**Error message:**
```
error: expected ';' before 'cout'
```

**Fixed code:**
```cpp
int age = 25;  // Added semicolon
cout << age << endl;
```

::: notes
Point out that the error message points to the cout line, but the actual problem is on the previous line. This is a common pattern that confuses beginners.
:::

## Common Error: Mismatched Braces

**Broken code:**
```cpp
int main() {
    cout << "Hello" << endl;
    return 0;
// Missing closing brace
```

**Error message:**
```
error: expected '}' at end of input
```

**Fixed code:**
```cpp
int main() {
    cout << "Hello" << endl;
    return 0;
}  // Added closing brace
```

::: notes
Emphasize the importance of matching every opening brace with a closing brace. Many IDEs can help by highlighting matching braces when you click on one.
:::

## Common Error: Undefined Variable

**Broken code:**
```cpp
int age = 25;
cout << aeg << endl;  // Typo: aeg instead of age
```

**Error message:**
```
error: 'aeg' was not declared in this scope
```

**Fixed code:**
```cpp
int age = 25;
cout << age << endl;  // Fixed typo
```

::: notes
Variable name typos are extremely common. Encourage students to use descriptive variable names and enable compiler warnings for unused variables, which can help catch these errors.
:::

## Debugging Technique 1: <br> Read Error Messages

**Step 1: Read the first error message** - Fixing the first error often makes subsequent errors disappear.

**Step 2: Locate the line number** - Example: `main.cpp:15:5:` means line 15, column 5.

**Step 3: Read the description** - "expected ';' before 'cout'" means you forgot a semicolon.

**Step 4: Check that line AND the line before** - The error is often on the previous line.

**Step 5: Fix and recompile** - Make the fix, save, and compile again.

::: notes
Walk through this process with a live example if possible. Show how one missing semicolon can generate multiple cascading errors, and how fixing that one error makes them all disappear.
:::

## Debugging Technique 2:<br> Comment Out Code

When you're unsure what's causing an error, systematically comment out sections of code.

**Original broken code:**
```cpp
int main() {
    int x = 10;
    int y = 20;
    int z = x + y;
    cout << "Result: " << z << endl;
    int a = 5 / 0;  // This causes a problem
    cout << "Done" << endl;
    return 0;
}
```

---

**Comment out suspicious sections:**
```cpp
int main() {
    int x = 10;
    int y = 20;
    int z = x + y;
    cout << "Result: " << z << endl;
    
    // Commenting out to test
    // int a = 5 / 0;
    // cout << "Done" << endl;
    
    return 0;
}
```

If it works now, the problem is in the commented section.

::: notes
Demonstrate how to use multi-line comments (/* */) for larger sections. This technique is especially useful when you have a general idea where the bug is but aren't sure exactly which line.
:::

## Debugging Technique 3:<br> Print Statements

**The most basic and effective debugging tool is cout statements.** Use `cout` to see what's happening inside your code.

**Example problem - Wrong calculation:**
```cpp
int main() {
    int score1 = 85;
    int score2 = 92;
    int score3 = 78;
    
    int average = score1 + score2 + score3 / 3;  // BUG!
    
    cout << "Average: " << average << endl;
    return 0;
}
```

**Output:** `Average: 203` (This is wrong!)

## Print Statements: Debugging the Calculation

Add strategic print statements to understand what's happening:

```cpp
int main() {
    int score1 = 85;
    int score2 = 92;
    int score3 = 78;
    
    // Debug: Print individual values
    cout << "Score 1: " << score1 << endl;  // 85 ✓
    cout << "Score 2: " << score2 << endl;  // 92 ✓
    cout << "Score 3: " << score3 << endl;  // 78 ✓
    
    int average = score1 + score2 + score3 / 3;
    cout << "Average: " << average << endl;  // 203 - Wrong!
    
    return 0;
}
```

The values are correct, so the problem must be in the calculation. The fix: add parentheses to force correct order of operations.

---

**Corrected:** `int average = (score1 + score2 + score3) / 3;`

::: notes
Explain that without parentheses, only score3 is divided by 3 due to operator precedence. Walk through the math: 85 + 92 + (78/3) = 85 + 92 + 26 = 203. With parentheses: (85+92+78)/3 = 255/3 = 85.
:::

## Debugging Technique 4:<br> Simplify the Problem

Break complex problems into smaller, testable pieces.

**Complex problem:**
```cpp
double result = (a + b) * c / (d - e) + f * g - h;
```

---

**Simplified debugging:**
```cpp
double sum = a + b;
cout << "sum = " << sum << endl;

double product1 = sum * c;
cout << "product1 = " << product1 << endl;

double difference = d - e;
cout << "difference = " << difference << endl;

double quotient = product1 / difference;
cout << "quotient = " << quotient << endl;

double product2 = f * g;
cout << "product2 = " << product2 << endl;

double result = quotient + product2 - h;
cout << "result = " << result << endl;
```

::: notes
Emphasize that breaking complex expressions into steps has two benefits: easier to debug, and easier to read. Sometimes the "debugging" version is actually better code that should stay in the final program.
:::

## Debugging Technique 5:<br> Check Your Assumptions

Bugs often occur because we assume something that isn't true.

**Common false assumptions:**
- "I initialized that variable" (but you didn't)
- "Integer division gives decimals" (but it truncates)
- "The user will enter valid input" (but they enter invalid data)

Let's focus on the most common assumption error: integer division.

::: notes
Emphasize that experienced programmers explicitly verify their assumptions rather than trusting them. A diagram showing the difference between integer division (5/2 = 2) and floating-point division (5.0/2 = 2.5) would be helpful here.
:::

## Checking Assumptions:<br> Integer Division Example

**Buggy code:**
```cpp
int total = 100;
int count = 3;

double average = total / count;  // BUG!

cout << "Average: " << average << endl;  // Shows: 33 (not 33.333...)
```

**Debug by checking types:**
```cpp
cout << "total type: int, value: " << total << endl;
cout << "count type: int, value: " << count << endl;
cout << "total / count: " << (total / count) << endl;  // Integer division!
```

**Fix:**
```cpp
double average = static_cast<double>(total) / count;
```

::: notes
Explain that when both operands are integers, C++ performs integer division and discards the remainder. The result is then converted to double, but the precision is already lost. Casting one operand to double forces floating-point division.
:::

## The Debugging Process

- Reproduce the bug
- Isolate the problem
- Understand the bug
- Fix the bug
- Test the fix
- Learn from it

## The Debugging Process: Steps 1-3

**Step 1: Reproduce the bug** - Make sure you can consistently cause the bug to happen.

**Step 2: Isolate the problem**

- Comment out code sections
- Test with simple inputs
- Add print statements

**Step 3: Understand the bug**

- Why is it happening?
- What assumption was wrong?

Once you understand the bug, you're ready to fix it systematically.

::: notes
Emphasize that understanding comes before fixing. Students often want to jump straight to changing code, but understanding the root cause prevents creating new bugs while fixing the old one.
:::

## The Debugging Process: Steps 4-6

**Step 4: Fix the bug** - Make the smallest change possible to fix it.

**Step 5: Test the fix**

- Does it work now?
- Did you break anything else?
- Test with multiple inputs

**Step 6: Learn from it**

- Why did this bug happen?
- How can you avoid it in the future?

::: notes
Emphasize "smallest change possible" - changing multiple things at once makes it unclear which change fixed the bug. Testing with multiple inputs is crucial because a fix that works for one input might fail for others.
:::

## Practice Debugging Strategies

**Binary search debugging:** If you have a long program, comment out half and test. Keep narrowing down where the bug is.

**Rubber duck debugging:** Explain your code line-by-line to someone (or a rubber duck). Often you'll find the bug while explaining.

**Take a break:** If you're stuck for more than 15 minutes, take a 5-minute break. Fresh eyes find bugs faster.

**Start from scratch:** Sometimes it's easier to rewrite a small section than debug it.

**Compare to working code:** Look at similar working examples and see what's different.

::: notes
Emphasize that professional programmers use all these strategies regularly. There's no shame in taking a break or asking for help. The rubber duck method works because verbalizing forces you to think through each step carefully.
:::


## Summary

Debugging is a systematic process: read error messages carefully, use print statements strategically, and test frequently. Every programmer debugs constantly - mastering these techniques will make you a confident, efficient developer.

::: notes
Reinforce that debugging is normal and that the techniques covered today are used by professional programmers every day.
:::