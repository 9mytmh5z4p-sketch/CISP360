# Mutation with Reference Variables in For-Each Loops

## How can you modify elements<br> inside a for-each loop?

By default, for-each loops create copies of elements, which means changes won't affect the original container. To modify the actual elements, you need to use reference variables with the `&` symbol in your loop declaration.

::: notes
Total slides in main content: 9 (not including 7 appendix slides)

This section assumes students understand basic for-each loop syntax and reference variables as separate concepts. We're now combining them to enable mutation of container elements.
:::

<!-- Slide 1 -->

## The Copy Problem

When you use a basic for-each loop, each iteration creates a copy of the element. Modifications affect only the copy, not the original container. C++ defaults to copying as a safety mechanism - it prevents unintended changes to your data.

```cpp
vector<int> scores = {85, 90, 78};

for (int score : scores) {
    score += 5;                    // Modifies the COPY
}

// scores is now {85, 90, 78} - unchanged!
```

::: notes
A diagram would be helpful here showing the vector in memory and separate copied values being created and modified, with arrows showing that changes don't flow back to the original container. Emphasize that the copy is created fresh on each iteration and discarded when the iteration ends. The default-to-copy behavior prevents bugs where you accidentally modify data you meant to just read.
:::

<!-- Slide 2 -->

## Reference Solution

Adding `&` after the type makes the loop variable a reference to the actual element. Changes now affect the original container.

```cpp
vector<int> scores = {85, 90, 78};

for (int& score : scores) {        // Note the &
    score += 5;                    // Modifies the ORIGINAL
}

// scores is now {90, 95, 83} - modified!
```

The reference creates an alias to each element rather than copying it.

::: notes
A diagram comparing this to the previous slide would be effective. Show the loop variable pointing directly to elements in the container rather than to separate copies. Emphasize that the & makes score an alias for each actual element in the vector. This is the key difference: without &, you get a copy; with &, you get direct access to the original.
:::

<!-- Slide 3 -->

## Mutation Example

References allow you to update container elements in place without index-based access.

```cpp
vector<double> prices = {19.99, 29.99, 39.99};

// Apply 10% discount to all prices
for (double& price : prices) {
    price *= 0.90;
}

// prices is now {17.991, 26.991, 35.991}
```

Without the `&`, the discount would be calculated but not applied to the original prices.

::: notes
Trace through one iteration showing how price is bound to prices[0], modified in place, then the loop moves to prices[1], etc. Contrast this with what would happen without the & - the calculation would occur but the vector would remain unchanged. This is a common source of silent bugs.
:::

<!-- Slide 4 -->

## Const Reference

Using `const &` creates a reference without allowing modification. This avoids copying large objects while preventing accidental changes.

```cpp
vector<string> names = {"Alice", "Bob", "Charlie"};

for (const string& name : names) {  // Read-only reference
    cout << name << endl;           // Can read
    // name += "!";                 // ERROR: cannot modify
}
```

This is efficient for large objects like strings, avoiding the overhead of copying while maintaining safety.

::: notes
Emphasize the efficiency benefit: with plain string (no &), each name would be copied. With const string&, we get direct access without copying and without the ability to accidentally modify. This is particularly important for expensive-to-copy types like strings, vectors, or custom objects. Point out that const& gives you the best of both worlds: efficiency of references plus safety of immutability.
:::

<!-- Slide 5 -->

## Syntax Comparison {.smallest-table}

| Loop Type | Syntax | Creates Copy? | Can Modify Original? | Use When |
|-----------|--------|---------------|---------------------|----------|
| Copy | `for (Type item : container)` | Yes | No | Small types, no modification needed |
| Reference | `for (Type& item : container)` | No | Yes | Need to modify elements |
| Const Reference | `for (const Type& item : container)` | No | No | Large types, read-only access |

The choice depends on whether you need to modify elements and whether copying is expensive.

::: notes
Walk through each row of the table with examples from previous slides. Point out that for small types like int, copying is cheap so Type item is fine for read-only. For large types like string or custom objects, const Type& is better for read-only. Only use Type& when you actually need to modify. Now that students have seen concrete examples, this table should make more sense.
:::

<!-- Slide 6 -->

## When to Use Each

**Use copy** (`Type item`) when working with small primitive types (int, double, char, bool) and not modifying.

**Use reference** (`Type& item`) when you need to modify the original elements.

**Use const reference** (`const Type& item`) when reading large objects (string, vector, custom classes) without modification.

::: notes
Provide clear size guidance: primitive types (int, double, char, bool) are small - copying is fine and actually faster than reference overhead. string, vector, and custom classes can be arbitrarily large - use const & for read-only to avoid expensive copies. Only add mutability (remove const) when you actually need to change elements.
:::

<!-- Slide 7 -->

## Practical Application

A common use case is updating all elements in a container based on some calculation or condition.

```cpp
vector<double> temperatures = {98.6, 99.1, 100.4, 97.8};

// Convert from Fahrenheit to Celsius
for (double& temp : temperatures) {
    temp = (temp - 32.0) * 5.0 / 9.0;
}

// temperatures is now {37.0, 37.28, 38.0, 36.56}
```

Using references makes the code cleaner than index-based loops while still allowing modification.

::: notes
This example demonstrates a realistic mutation scenario without introducing new concepts like structs. Walk through how each temperature is converted in place. Contrast with an index-based approach: for(int i = 0; i < temperatures.size(); i++) { temperatures[i] = ... } - the reference version is more readable and less error-prone.
:::

<!-- Slide 8 -->

## Summary

To modify elements in a for-each loop, use a reference variable by adding `&` after the type. Use `const &` for efficient read-only access to large objects, and plain copies for small types when modification isn't needed.

::: notes
Reinforce the three-way decision: copy for small read-only, const reference for large read-only, mutable reference for modification. This concept applies broadly - it's not just for loops but for any situation where you need to decide how to pass or access data.
:::

<!-- Slide 9 -->

## Appendix

<!-- Slide 10 -->

## Good Practices

**Prefer const references for large objects** - When you don't need to modify elements, use `const Type&` to avoid copying expensive objects while preventing accidental changes.

**Use meaningful names** - The loop variable should clearly indicate what each element represents (e.g., `student` not `s`, `price` not `p`).

**Choose the right loop type** - Reserve references for when you actually need mutation; don't default to references if copies work fine.

**Be consistent** - If you use references in one part of your code for a container type, use the same approach elsewhere unless there's a specific reason to differ.

<!-- Slide 11 -->

## Common Mistakes

**Forgetting the `&` when modification is intended:**
```cpp
for (int score : scores) {  // Missing &
    score += 10;            // Changes lost!
}
```
The loop runs without error but changes aren't saved, making this a silent bug.

**Using references when copies would work:**
```cpp
for (int& num : numbers) {  // Unnecessary &
    cout << num;            // Just reading
}
```
Adding `&` unnecessarily can make code harder to reason about since readers must consider whether mutation occurs.

**Using mutable references when const references suffice:**
```cpp
for (string& name : names) {  // Should be const string&
    cout << name;             // Just printing
}
```
This opens the door to accidental modifications and makes code less safe.

<!-- Slide 12 -->

## More Examples

**Example 1: Normalizing data**
```cpp
vector<double> values = {100, 200, 300};
double max = 300.0;

for (double& value : values) {
    value /= max;  // Normalize to 0-1 range
}
```

**Example 2: Making strings uppercase**
```cpp
vector<string> words = {"hello", "world"};

for (string& word : words) {
    for (char& c : word) {
        c = toupper(c);
    }
}
```

**Example 3: Read-only with const reference**
```cpp
vector<string> books = {"C++ Primer", "Effective C++"};

for (const string& book : books) {
    cout << "Reading: " << book << endl;
    // Cannot modify book here - compiler error if attempted
}
```

**Example 4: Calculating sum with const reference**
```cpp
vector<double> prices = {19.99, 29.99, 39.99};
double total = 0.0;

for (const double& price : prices) {
    total += price;  // Read-only: no copy, no modification
}
```

<!-- Slide 13 -->

## Practice Problems

**Problem 1:** Write a loop to double all values in `vector<int> numbers = {1, 2, 3, 4, 5};`

**Problem 2:** Write a loop to print all elements in `vector<string> cities` without copying the strings.

**Problem 3:** Given `vector<double> temperatures = {98.6, 99.1, 97.8};`, convert all values from Fahrenheit to Celsius using the formula `C = (F - 32) * 5/9`.

**Problem 4:** Write a loop to count how many strings in `vector<string> names` are longer than 5 characters without copying them.

**Problem 5:** Explain why this code doesn't modify the original vector: `for (int score : scores) { score *= 2; }` What needs to change?

<!-- Slide 14 -->

## AI Search Terms

**Core concepts:**
- "C++ range-based for loop with references"
- "for each loop modify elements C++"
- "C++ auto& in range-based for"

**Efficiency and const:**
- "const reference in for loop C++"
- "avoid copying in range-based for loop"
- "C++ for loop reference vs copy performance"

**Troubleshooting:**
- "C++ for loop not modifying vector elements"
- "reference vs value in range-based for"
- "when to use const auto& in C++"

<!-- Slide 15 -->

## Questions for Reflection

**Conceptual understanding:**
- Why does the compiler allow you to modify a copy in a for-each loop even though the changes won't persist?
- When would using a copy be preferable to using a const reference, even for large objects?

**Application:**
- If you see `for (auto& item : container)`, what can you infer about the programmer's intent?
- How would you explain to a peer why their for-each loop isn't updating the original vector?

**Design decisions:**
- In what situations might you intentionally want to work with copies rather than references?
- How does the choice between copy, reference, and const reference relate to the principle of least privilege in programming?

<!-- Slide 16 -->