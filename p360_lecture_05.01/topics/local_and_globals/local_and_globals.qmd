# Global and Local Variables in C++

::: notes
~15
::: 

## Review: Scope

Recall from our earlier discussions we discussed scope. And we saw that depending upon where a variable exists in the program, it has a different lifespan.

::: notes
**Speaker Notes:** Display a diagram showing the stack and data segment, with arrows indicating where local and global variables are stored.
:::

## Block Scope

The technical term for what we were referring to is known as **block scope**.

```cpp
void demo() {
    int x = 5;          // Function scope
    if (x > 0) {
        int y = 10;     // Block scope (if block)
        cout << y;      // Valid
    }
    // cout << y;       // ERROR: y doesn't exist here
}
```


::: notes
**Speaker Notes:** Show nested boxes representing the function scope containing the if-block scope, illustrating how inner scopes are contained within outer scopes.
Block scope is even more restrictive than function scope.

::: 

## Block Scope Examples

```cpp
int main() {
    for (int i = 0; i < 5; i++) {
        int temp = i * 2;       // temp exists only in loop
        cout << temp << " ";
    }
    // cout << i;               // ERROR: i doesn't exist here
    // cout << temp;            // ERROR: temp doesn't exist here
    
    int i = 100;                // Valid: loop's i no longer exists
    cout << i;                  // Prints 100
    return 0;
}
```

Loop variables like `i` and variables declared within the loop have block scope limited to that loop.




## Functions Add Another<br> Dimension to Scope

- local variables
- global variables



## Local Variables

Local variables are declared inside a function or block of code. They can only be accessed within the function or block where they are declared. Once the function or block ends, the local variable ceases to exist.

```cpp
// Assumes: #include <iostream> and using namespace std;
void example() {
    int localVar = 10;  // Local to example()
    cout << localVar;   // Valid: inside the function
}
// localVar does not exist here
```

The scope of `localVar` is limited to the `example()` function.

## Local Variable Characteristics

**Lifetime:** Local variables are created when program execution enters their scope and destroyed when execution leaves. This automatic management happens on the stack.

**Accessibility:** Local variables can only be accessed within the function or block where they are declared. We call this "function scope" when a variable is accessible throughout an entire function. Attempting to access them elsewhere causes a compilation error.

**Storage:** Local variables are stored on the stack, making their creation and destruction very efficient.

::: notes
**Speaker Notes:** Create a timeline diagram showing a local variable being created at function entry, existing during execution, and being destroyed at function exit.
::: 

## Local Variable Examples

```cpp
int add(int, int);

int main() {
    int result = add(5, 3);
    cout << result;     // Prints 8
    // cout << sum;     // ERROR: sum doesn't exist here
    return 0;
}
int add(int a, int b) {
    int sum = a + b;    // sum is local to add()
    return sum;
}
```

Each function has its own local variables. The `sum` variable exists only inside `add()` and cannot be accessed from `main()`.



## Global Variables

Global variables are declared outside all functions, typically at the top of your program file. They can be accessed from any function in the program. Global variables exist for the entire duration of program execution.

---

```cpp
using namespace std;

int globalVar = 100;    // Global variable

void function1();
void function2();


int main() {
    // main stuff, has access to global var
}

void function1() {
    cout << globalVar;  // Can access globalVar
}

void function2() {
    globalVar = 200;    // Can modify globalVar
}
```

All functions in the program can see and use `globalVar`.

## Global Variable Characteristics

**Lifetime:** Global variables are created when the program starts and destroyed when the program ends. They persist for the entire program execution.

**Accessibility:** Global variables can be accessed from any function in the program after their declaration. This makes them available throughout your code.

**Storage:** Global variables are stored in the data segment of memory, not on the stack.

::: notes
**Speaker Notes:** Display a diagram showing the data segment with a global variable, and multiple function stack frames all having access to that global variable.
::: 

## Global Variable Examples

```cpp
#include <iostream>
using namespace std;

int counter = 0;        // Global variable

void increment();

int main() {
    cout << counter;    // Prints 0
    increment();
    cout << counter;    // Prints 1
    increment();
    cout << counter;    // Prints 2
    return 0;
}

void increment() {
    counter++;          // Modifies the global counter
}
```

The `counter` variable persists across multiple function calls and can be modified by any function.


## Comparing Local and Global Variables

| Characteristic | Local Variables | Global Variables |
|----------------|-----------------|------------------|
| **Declaration** | Inside functions or blocks | Outside all functions |
| **Lifetime** | Exist only during function/block execution | Exist for entire program duration |
| **Storage** | Stored on the stack | Stored in the data segment |
| **Accessibility** | Accessible only within their scope | Accessible from all functions |
| **Management** | Automatically created and destroyed | Created at program start, destroyed at program end |

Choose the appropriate type based on whether data needs to be shared across functions or kept isolated.

## Variable Shadowing

Remember, Shadowing occurs when a local variable has the same name as a global variable. The local variable "shadows" or hides the global variable within its scope. In the local scope, the local variable is accessed, not the global one.

```cpp
int value = 100;        // Global variable

void test() {
    int value = 50;     // Local variable shadows global
    cout << value;      // Prints 50, not 100
}
```

The local `value` hides the global `value` inside the `test()` function.


## Shadowing with a Function

```cpp
int score = 20;

void PrintStuff(int);

int main() {
    cout << score;      // 20

    int score = 30;
    PrintStuff(score);
    cout << score;      // 30

    {
        int score = 50;
        cout << score;  // 50
    }
}
void PrintStuff(int score) { //help keep track 
    score = 40;
    cout << score;          // 40
}
```

Each scope level can have its own variable with the same name. The most local version is always accessed.

::: notes
**Speaker Notes:** Create a diagram showing three nested rectangles representing global scope, function scope, and block scope, each containing a variable named 'x' with different values.
:::

## Good Practices

**Prefer local variables:** Use local variables whenever possible to keep data isolated and functions independent. This makes code easier to understand and debug.

**Minimize global variables:** Use global variables very sparingly, only for data that truly needs to be accessed throughout the entire program. Too many globals make code harder to maintain and test.

**Use global constants when appropriate:** Global constants (const variables) are more acceptable than global variables because they cannot be accidentally modified and provide program-wide configuration values.

**Avoid shadowing:** Give variables distinct names to avoid confusion and errors. Shadowing can make code difficult to read and debug.

## Practical Application

```cpp
#include <iostream>
using namespace std;

int totalScore = 0;     // Global: tracks cumulative score

void addPoints(int points) {
    int bonus = 10;     // Local: temporary calculation
    int earned = points + bonus;
    totalScore += earned;
    cout << "Earned: " << earned << endl;
}

int main() {
    cout << "Total: " << totalScore << endl;  // Prints 0
    addPoints(50);                             // Earned: 60
    addPoints(30);                             // Earned: 40
    cout << "Total: " << totalScore << endl;  // Prints 100
    return 0;
}
```

This example shows appropriate use of both global and local variables. The global `totalScore` persists across function calls, while local variables handle temporary computations.

::: notes
**Speaker Notes:** Walk through the execution step-by-step: (1) totalScore starts at 0 in data segment, (2) first addPoints call creates bonus=10 and earned=60 on stack, adds 60 to totalScore, then destroys local variables, (3) second addPoints call creates new bonus=10 and earned=40 on stack, adds 40 to totalScore making it 100, then destroys local variables, (4) totalScore persists throughout in data segment while local variables come and go on the stack.
::: 

