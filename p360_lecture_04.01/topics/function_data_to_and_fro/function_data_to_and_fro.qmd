# Passing Data To and From Functions

::: notes
Target duration: ~20 minutes
:::

## Agenda

Today's topics:

- Understanding parameters and arguments
- Passing data into functions
- Returning data from functions
- Function prototypes
- Common mistakes and how to avoid them
- Practical examples

::: notes
This lecture builds on void functions by showing how to make functions more flexible and powerful through data passing.
:::

## Why Functions Need Data

Consider this function:

```cpp
void displayName() {
    cout << "Hello, Alice!" << endl;
}
```

**Problem:** This only works for Alice. What about Bob or Charlie?

**Challenge:** How can we make one function work for any name?

**Solution:** Give functions the ability to receive and process different data.

## Parameters: Receiving Data

**Parameters** are variables in the function definition that receive data.

```cpp
void displayName(string name) {
    cout << "Hello, " << name << "!" << endl;
}
```

**Anatomy:**
- `string` is the data type
- `name` is the parameter variable
- Parameters exist only inside the function

::: notes
A diagram showing the function definition with the parameter highlighted would be useful here.
:::

## Arguments vs Parameters

**Parameter:** Variable in the function definition (placeholder)

**Argument:** Actual value passed when calling the function (real data)

```cpp
void displayName(string name) {     // name is a PARAMETER
    cout << "Hello, " << name << "!" << endl;
}

int main() {
    displayName("Alice");           // "Alice" is an ARGUMENT
    return 0;
}
```

The argument value is copied into the parameter variable.

## Single Parameter Example

```cpp
#include <iostream>
using namespace std;

void greet(string person) {
    cout << "Welcome, " << person << "!" << endl;
}

int main() {
    greet("Alice");
    greet("Bob");
    greet("Charlie");
    return 0;
}
```

**Output:**
```
Welcome, Alice!
Welcome, Bob!
Welcome, Charlie!
```

## Multiple Parameters

Functions can accept multiple pieces of data:

```cpp
void displayProduct(string name, double price) {
    cout << name << " costs $" << price << endl;
}

int main() {
    displayProduct("Laptop", 899.99);
    displayProduct("Mouse", 24.50);
    return 0;
}
```

**Key rules:**
- Separate parameters with commas
- Each parameter needs a type
- Order matters - arguments must match parameter order

::: notes
Emphasize that you cannot write `string name, price` - each parameter needs its own type. Show what happens when you call with arguments in wrong order.
:::

## Parameter Order and Types

Arguments must match parameters in **order** and **type**:

```cpp
void displayStudent(string name, int age, double gpa) {
    cout << name << " is " << age << " years old" << endl;
    cout << "GPA: " << gpa << endl;
}

int main() {
    displayStudent("Alice", 20, 3.8);     // Correct
    displayStudent(20, "Alice", 3.8);     // ERROR - wrong types
    return 0;
}
```

::: notes
Consider showing a visual matching of arguments to parameters with arrows. Demonstrate the compiler error message for type mismatch.
:::

## Function Prototypes

**Problem:** C++ requires functions to be defined before they're called.

**Solution:** Declare the function's signature at the top with a **prototype**.

```cpp
// Prototype (declaration) - tells compiler function exists
void displayStudent(string name, int age, double gpa);

int main() {
    displayStudent("Alice", 20, 3.8);  // Can call here
    return 0;
}

// Definition (implementation) - actual code
void displayStudent(string name, int age, double gpa) {
    cout << name << " is " << age << " years old" << endl;
}
```

::: notes
Explain that prototypes are especially important when working with multiple files. The prototype is like a table of contents - it tells the compiler what to expect.
:::

## Prototype Syntax

```cpp
// Full prototype with parameter names (recommended)
double calculateAverage(double score1, double score2, double score3);

// Parameter names optional, but less clear
double calculateAverage(double, double, double);

// Multiple prototypes
void displayMenu();
int getChoice();
double calculateTax(double amount);
```

**Best practice:** Include parameter names for readability. They don't have to match the definition's names, but usually do.

::: notes
Show students where prototypes typically go: after includes and namespace, before main. Mention that professional code often puts prototypes in header files (.h).
:::

## Return Values: Sending Data Back

**So far:** Functions receive data through parameters (input)

**Now:** Functions can send data back through return values (output)

```cpp
int add(int a, int b) {
    return a + b;
}
```

**Key components:**
- `int` is the return type
- `return` statement sends the value back
- Return type must match the returned value

::: notes
A data flow diagram showing data going into the function via parameters and coming out via return would be helpful. Emphasize this completes the picture: data in (parameters) and data out (return).
:::

## Using Return Values

```cpp
int add(int a, int b) {
    return a + b;
}

int main() {
    // Store in a variable
    int result = add(5, 3);
    cout << "Result: " << result << endl;
    
    // Use directly in expression
    cout << "Sum: " << add(10, 20) << endl;
    
    // Pass to another function
    cout << add(5, add(2, 3)) << endl;
    
    return 0;
}
```

::: notes
Emphasize the flexibility of return values. The inner add(2,3) executes first, returns 5, then add(5,5) executes. This demonstrates function composition.
:::

## Return Type Must Match

The return statement must match the function's return type:

```cpp
int getValue() {
    return 3.14;        // WARNING - truncated to 3
}

double getNumber() {
    return 42;          // OK - converts to 42.0
}

string getName() {
    return 123;         // ERROR - cannot convert int to string
}
```

**Rule:** The compiler will error or warn if types don't match or convert properly.

::: notes
Demonstrate the actual compiler warnings/errors. Explain implicit conversion (int to double is safe, double to int loses precision). String conversion requires explicit methods like to_string().
:::

## Multiple Return Statements

Functions can have multiple returns, but only one executes:

```cpp
char getLetterGrade(int score) {
    if (score >= 90) {
        return 'A';
    }
    if (score >= 80) {
        return 'B';
    }
    if (score >= 70) {
        return 'C';
    }
    if (score >= 60) {
        return 'D';
    }
    return 'F';
}
```

**Important:** Once a return executes, the function immediately exits.

## Common Mistake: Missing Return

```cpp
int getValue() {
    int x = 10;
    // ERROR - no return statement
}
```

**Compiler error:** Control reaches end of non-void function.

**Fix:**
```cpp
int getValue() {
    int x = 10;
    return x;
}
```

**Rule:** Non-void functions must return a value on all code paths.

## Common Mistake: Argument Count and Type

```cpp
void displayInfo(string name, int age) {
    cout << name << " is " << age << endl;
}

int main() {
    displayInfo("Alice");           // ERROR - missing argument
    displayInfo("Bob", 20, 3.5);    // ERROR - too many arguments
    displayInfo("Charlie", "20");   // ERROR - wrong type
    displayInfo("David", 25);       // CORRECT
    return 0;
}
```

**Fix:** Match the exact number, order, and types of parameters.

## Example: Temperature Conversion

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

double celsiusToFahrenheit(double celsius);  // Prototype

int main() {
    double tempC = 25.0;
    double tempF = celsiusToFahrenheit(tempC);
    
    cout << fixed << setprecision(1);
    cout << tempC << "째C = " << tempF << "째F" << endl;
    
    return 0;
}

double celsiusToFahrenheit(double celsius) {
    return (celsius * 9.0 / 5.0) + 32.0;
}
```

**Output:** `25.0째C = 77.0째F`

## Example: Grade Determination

```cpp
#include <iostream>
using namespace std;

char determineGrade(double average);  // Prototype

int main() {
    char grade = determineGrade(87.5);
    cout << "Grade: " << grade << endl;
    return 0;
}

char determineGrade(double average) {
    if (average >= 90) return 'A';
    if (average >= 80) return 'B';
    if (average >= 70) return 'C';
    if (average >= 60) return 'D';
    return 'F';
}
```

**Output:** `Grade: B`

## Comprehensive Example: Grade Calculator

```cpp
#include <iostream>
using namespace std;

// Prototypes
double calculateAverage(int s1, int s2, int s3);
char determineGrade(double average);
void displayResults(string name, double avg, char grade);

int main() {
    string student = "Alice";
    double avg = calculateAverage(85, 92, 88);
    char grade = determineGrade(avg);
    displayResults(student, avg, grade);
    return 0;
}
```

**Output:**
```
Alice's average: 88.3333
Letter grade: B
```

::: notes
This example demonstrates the complete workflow: prototypes at top, main coordinates the logic, definitions below.

Function implementations:
```cpp
double calculateAverage(int s1, int s2, int s3) {
    return (s1 + s2 + s3) / 3.0;
}

char determineGrade(double average) {
    if (average >= 90) return 'A';
    if (average >= 80) return 'B';
    if (average >= 70) return 'C';
    if (average >= 60) return 'D';
    return 'F';
}

void displayResults(string name, double avg, char grade) {
    cout << name << "'s average: " << avg << endl;
    cout << "Letter grade: " << grade << endl;
}
```

Walk through the flow: main calls calculateAverage with 3 test scores, stores result, calls determineGrade with the average, then displayResults shows the output. This demonstrates how functions work together to solve a complete problem.
:::