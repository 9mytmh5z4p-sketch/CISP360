<!DOCTYPE html>
<html lang="en"><head>
<script src="p360_lecture_04.01_combined_files/libs/clipboard/clipboard.min.js"></script>
<script src="p360_lecture_04.01_combined_files/libs/quarto-html/tabby.min.js"></script>
<script src="p360_lecture_04.01_combined_files/libs/quarto-html/popper.min.js"></script>
<script src="p360_lecture_04.01_combined_files/libs/quarto-html/tippy.umd.min.js"></script>
<link href="p360_lecture_04.01_combined_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="p360_lecture_04.01_combined_files/libs/quarto-html/light-border.css" rel="stylesheet">
<link href="p360_lecture_04.01_combined_files/libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.8.26">

  <meta name="author" content="Dr.&nbsp;Caleb Fowler">
  <title>CISP 360 Structured Programming</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="p360_lecture_04.01_combined_files/libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="p360_lecture_04.01_combined_files/libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="p360_lecture_04.01_combined_files/libs/revealjs/dist/theme/quarto-99eeafcedac04850354b682963cedae3.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <link href="p360_lecture_04.01_combined_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="p360_lecture_04.01_combined_files/libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="p360_lecture_04.01_combined_files/libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="p360_lecture_04.01_combined_files/libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">CISP 360 Structured Programming</h1>
  <p class="subtitle">Introduction to C++</p>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Dr.&nbsp;Caleb Fowler 
</div>
</div>
</div>

</section>
<section id="last-time" class="slide level2">
<h2>Last Time</h2>
<ul>
<li>Scope</li>
<li>Shadow Variables I</li>
<li>Advanced <code>cin</code></li>
<li>Random Numbers</li>
</ul>
<aside class="notes">
<p>
Welcome back everyone! <pause> Last time, we covered four important concepts. We explored scope - understanding where variables are visible and accessible in your code. We looked at shadow variables and how local variables can hide variables from outer scopes. We also learned advanced cin techniques for reading input more effectively, and finally we worked with random number generation in C++. These concepts gave us more control over how our programs handle data and manage information flow. Today, we’re taking the next big step by learning how to organize our code using functions.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="todays-agenda" class="slide level2">
<h2>Today’s Agenda</h2>
<ul>
<li>Function Centric Architecture</li>
<li>Functions</li>
<li>Void Functions</li>
<li>Passing Data In and Out of Functions</li>
</ul>
<aside class="notes">
<p>
Today’s lecture is all about functions - one of the most fundamental organizing principles in programming. We’ll start by understanding function-centric architecture - the overall philosophy of how we structure programs around functions. Then we’ll learn how to create and use functions in C++. We’ll explore void functions, which perform actions without returning values, and finally we’ll see how to pass data into functions and get results back. By the end of today, you’ll be able to break complex problems into smaller, manageable pieces using functions.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section>
<section id="function-centered-architecture" class="title-slide slide level1 center">
<h1>Function Centered Architecture</h1>
<aside class="notes">
<p>
Let’s begin with the big picture - what is function-centric architecture and why does it matter? This sets the foundation for everything we’ll do today.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-centered-architecture-1" class="slide level2">
<h2>Function Centered Architecture</h2>
<p>Function-centric architecture refers to a program design approach where the code is organized primarily around functions (procedures) rather than objects or classes.</p>
<p>A function is a block of code we assign a name to. We call the name to execute the code.</p>
<aside class="notes">
<p>
Function-centric architecture is one of the primary ways we organize code. At its core, it’s simple: we take blocks of code, give them meaningful names, and then call those names when we want to execute that code. Think of it like creating custom commands - instead of writing the same code over and over, we package it up, name it, and reuse it. This approach separates our program’s data from its behavior, with functions operating on data rather than bundling them together. While this might seem basic now, it’s the foundation of structured programming and will serve you well throughout your programming journey.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="other-architectures" class="slide level2">
<h2>Other Architectures</h2>
<ul>
<li>Object Oriented</li>
<li>Spaghetti Coding</li>
</ul>
<aside class="notes">
<p>
Before we dive deeper into function-centric architecture, it’s worth knowing there are other ways to organize code. Object-oriented programming, which we’ll study later in this course, bundles data and functions together into objects. And then there’s spaghetti coding - which isn’t really an architecture at all, it’s what happens when you don’t use any organizing principles. Let’s see what that looks like.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="object-oriented-architecture" class="slide level2">
<h2>Object-Oriented Architecture</h2>
<ul>
<li>Organized around classes/objects.</li>
<li>Data and functions bundled together (mini programs).</li>
<li>Focus: “What entities/objects exist?”</li>
</ul>
<aside class="notes">
<p>
In object-oriented programming, which we’ll cover later in the course, we organize code around objects that represent real-world entities. Each object contains both its data and the functions that operate on that data - they’re bundled together into self-contained units. The design process starts by asking “what things exist in my problem domain?” rather than “what tasks do I need to perform?” We won’t spend more time on this now, but I wanted you to see the contrast with the function-centric approach we’re learning today.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="spaghetti-coding" class="slide level2">
<h2>Spaghetti Coding</h2>
<p>Just type it in as you go along.</p>
<aside class="notes">
<p>
Now let’s look at what happens when you have no architecture at all - what we call spaghetti coding. This is when you just start typing code without any planning or organization. It’s called spaghetti code because the logic gets so tangled and messy, like a plate of spaghetti. Let me show you an example using the goto statement, which allows you to jump around in your code randomly.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb1-4"><a href=""></a></span>
<span id="cb1-5"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-6"><a href=""></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores <span class="op">=</span> <span class="op">{</span><span class="dv">85</span><span class="op">,</span> <span class="dv">92</span><span class="op">,</span> <span class="dv">78</span><span class="op">,</span> <span class="dv">95</span><span class="op">,</span> <span class="dv">88</span><span class="op">};</span></span>
<span id="cb1-7"><a href=""></a>    <span class="dt">int</span> index<span class="op">;</span></span>
<span id="cb1-8"><a href=""></a>    <span class="dt">int</span> total<span class="op">;</span></span>
<span id="cb1-9"><a href=""></a>    <span class="dt">double</span> average<span class="op">;</span></span>
<span id="cb1-10"><a href=""></a>    <span class="dt">int</span> highest<span class="op">;</span></span>
<span id="cb1-11"><a href=""></a></span>
<span id="cb1-12"><a href=""></a>    <span class="co">// Jump to display section</span></span>
<span id="cb1-13"><a href=""></a>    <span class="cf">goto</span> display_scores<span class="op">;</span></span>
<span id="cb1-14"><a href=""></a></span>
<span id="cb1-15"><a href=""></a>display_scores<span class="op">:</span></span>
<span id="cb1-16"><a href=""></a>    index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-17"><a href=""></a>display_loop<span class="op">:</span></span>
<span id="cb1-18"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>index <span class="op">&gt;=</span> scores<span class="op">.</span>size<span class="op">())</span> <span class="cf">goto</span> display_done<span class="op">;</span></span>
<span id="cb1-19"><a href=""></a>    cout <span class="op">&lt;&lt;</span> scores<span class="op">[</span>index<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">" "</span><span class="op">;</span></span>
<span id="cb1-20"><a href=""></a>    index<span class="op">++;</span></span>
<span id="cb1-21"><a href=""></a>    <span class="cf">goto</span> display_loop<span class="op">;</span></span>
<span id="cb1-22"><a href=""></a></span>
<span id="cb1-23"><a href=""></a>display_done<span class="op">:</span></span>
<span id="cb1-24"><a href=""></a>    cout <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb1-25"><a href=""></a>    <span class="cf">goto</span> calculate_average<span class="op">;</span></span>
<span id="cb1-26"><a href=""></a></span>
<span id="cb1-27"><a href=""></a>calculate_average<span class="op">:</span></span>
<span id="cb1-28"><a href=""></a>    total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-29"><a href=""></a>    index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-30"><a href=""></a>avg_loop<span class="op">:</span></span>
<span id="cb1-31"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>index <span class="op">&gt;=</span> scores<span class="op">.</span>size<span class="op">())</span> <span class="cf">goto</span> avg_done<span class="op">;</span></span>
<span id="cb1-32"><a href=""></a>    total <span class="op">+=</span> scores<span class="op">[</span>index<span class="op">];</span></span>
<span id="cb1-33"><a href=""></a>    index<span class="op">++;</span></span>
<span id="cb1-34"><a href=""></a>    <span class="cf">goto</span> avg_loop<span class="op">;</span></span>
<span id="cb1-35"><a href=""></a></span>
<span id="cb1-36"><a href=""></a>avg_done<span class="op">:</span></span>
<span id="cb1-37"><a href=""></a>    average <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>total<span class="op">)</span> <span class="op">/</span> scores<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-38"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Average: "</span> <span class="op">&lt;&lt;</span> average <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb1-39"><a href=""></a>    <span class="cf">goto</span> find_highest<span class="op">;</span></span>
<span id="cb1-40"><a href=""></a></span>
<span id="cb1-41"><a href=""></a>find_highest<span class="op">:</span></span>
<span id="cb1-42"><a href=""></a>    highest <span class="op">=</span> scores<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-43"><a href=""></a>    index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-44"><a href=""></a>high_loop<span class="op">:</span></span>
<span id="cb1-45"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>index <span class="op">&gt;=</span> scores<span class="op">.</span>size<span class="op">())</span> <span class="cf">goto</span> high_done<span class="op">;</span></span>
<span id="cb1-46"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>scores<span class="op">[</span>index<span class="op">]</span> <span class="op">&gt;</span> highest<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-47"><a href=""></a>        highest <span class="op">=</span> scores<span class="op">[</span>index<span class="op">];</span></span>
<span id="cb1-48"><a href=""></a>    <span class="op">}</span></span>
<span id="cb1-49"><a href=""></a>    index<span class="op">++;</span></span>
<span id="cb1-50"><a href=""></a>    <span class="cf">goto</span> high_loop<span class="op">;</span></span>
<span id="cb1-51"><a href=""></a></span>
<span id="cb1-52"><a href=""></a>high_done<span class="op">:</span></span>
<span id="cb1-53"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Highest: "</span> <span class="op">&lt;&lt;</span> highest <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb1-54"><a href=""></a>    <span class="cf">goto</span> program_end<span class="op">;</span></span>
<span id="cb1-55"><a href=""></a></span>
<span id="cb1-56"><a href=""></a>program_end<span class="op">:</span></span>
<span id="cb1-57"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-58"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Look at line 14 on your screen - we immediately jump to display_scores. Then line 24 jumps to calculate_average. Then line 37 jumps to find_highest. Notice how the flow jumps all over the place? To understand this code, you have to mentally jump around following all these goto statements. This style was common in early BASIC and FORTRAN, but we’ve learned better approaches since then.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="why-is-this-bad-code" class="slide level2">
<h2>Why is this bad code?</h2>
<ul>
<li>Unreadable - Jump around to understand flow</li>
<li>Unmaintainable - Hard to modify without breaking</li>
<li>Not reusable - Can’t call “display” from elsewhere</li>
<li>Error-prone - Easy to create infinite loops or skip code</li>
<li>Hard to debug - Control flow is non-linear</li>
<li>No abstraction - All details exposed in one place</li>
</ul>
<p><strong>Never, ever, code like this.</strong></p>
<aside class="notes">
<p>
This spaghetti code has serious problems. It’s unreadable - you have to jump around mentally to follow the logic. It’s unmaintainable - change one part and you risk breaking everything. There’s no reusability - you can’t call “display scores” from elsewhere, you’d have to copy all that code. <pause> In 1968, computer scientist Edsger Dijkstra wrote a famous paper called “Go To Statement Considered Harmful” that helped establish structured programming. Modern C++ strongly discourages goto - it’s considered a code smell. Never, ever code like this!
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-centric-architecture" class="slide level2">
<h2>Function Centric Architecture</h2>
<ol type="1">
<li>Functions are the primary building blocks of Structured Code</li>
</ol>
<ul>
<li>The program is decomposed into a collection of functions</li>
<li>Each function performs a specific task</li>
<li>Functions call other functions to accomplish complex operations</li>
</ul>
<aside class="notes">
<p>
Now let’s see the right way to structure code. In function-centric architecture, functions are our primary building blocks. We take a complex problem and decompose it into a collection of functions, where each function has one specific job to do. Then, to accomplish complex operations, we have functions call other functions. This creates a hierarchy of functionality - high-level functions coordinate the big picture by calling lower-level functions that handle specific details.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-centric-architecture-cont" class="slide level2">
<h2>Function Centric Architecture (cont)</h2>
<ol type="1">
<li>Functions are the primary building blocks of Structured Code</li>
<li>Data and behavior are separated</li>
</ol>
<ul>
<li>Data is typically stored in variables or structs</li>
<li>Functions operate on that data</li>
<li>Data is passed to functions as parameters</li>
</ul>
<aside class="notes">
<p>
The second key principle is separating data from behavior. Our data lives in variables or structs, and our functions operate on that data. This is different from object-oriented programming where data and behavior are bundled together. Here, we keep them separate - data is stored in one place, and we pass that data to functions as parameters when we need to do something with it. This separation makes it easier to understand what data exists in your program and what operations you can perform on it.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-centric-architecture-cont-1" class="slide level2">
<h2>Function Centric Architecture (cont)</h2>
<ol type="1">
<li>Functions are the primary building blocks of Structured Code</li>
<li>Data and behavior are separated</li>
<li>Top-down design approach:</li>
</ol>
<ul>
<li>Start with the main problem</li>
<li>Break it into smaller sub-problems (functions)</li>
<li>Each sub-problem becomes a function</li>
</ul>
<aside class="notes">
<p>
The third principle is using a top-down design approach. When faced with a problem, we start at the highest level - what’s the main thing we’re trying to accomplish? Then we break that down into smaller sub-problems. Each sub-problem becomes a function. If a sub-problem is still too complex, we break it down further into even smaller functions. This creates a natural hierarchy where main() coordinates the high-level logic, calling functions that handle the major tasks, and those functions might call other functions to handle details. <pause> Think of it like managing a project - you don’t do everything yourself, you delegate tasks to team members, and they might delegate sub-tasks to others. That’s exactly how function-centric architecture works.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="example" class="slide level2">
<h2>Example</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb2-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb2-4"><a href=""></a></span>
<span id="cb2-5"><a href=""></a><span class="co">// Function declarations</span></span>
<span id="cb2-6"><a href=""></a><span class="dt">double</span> calculateAverage<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores<span class="op">);</span></span>
<span id="cb2-7"><a href=""></a><span class="dt">void</span> displayScores<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores<span class="op">);</span></span>
<span id="cb2-8"><a href=""></a><span class="dt">int</span> findHighest<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores<span class="op">);</span></span>
<span id="cb2-9"><a href=""></a></span>
<span id="cb2-10"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-11"><a href=""></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores <span class="op">=</span> <span class="op">{</span><span class="dv">85</span><span class="op">,</span> <span class="dv">92</span><span class="op">,</span> <span class="dv">78</span><span class="op">,</span> <span class="dv">95</span><span class="op">,</span> <span class="dv">88</span><span class="op">};</span></span>
<span id="cb2-12"><a href=""></a></span>
<span id="cb2-13"><a href=""></a>    displayScores<span class="op">(</span>scores<span class="op">);</span></span>
<span id="cb2-14"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Average: "</span> <span class="op">&lt;&lt;</span> calculateAverage<span class="op">(</span>scores<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb2-15"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Highest: "</span> <span class="op">&lt;&lt;</span> findHighest<span class="op">(</span>scores<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb2-16"><a href=""></a></span>
<span id="cb2-17"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-18"><a href=""></a><span class="op">}</span></span>
<span id="cb2-19"><a href=""></a></span>
<span id="cb2-20"><a href=""></a><span class="dt">double</span> calculateAverage<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-21"><a href=""></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-22"><a href=""></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> score <span class="op">:</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-23"><a href=""></a>        total <span class="op">+=</span> score<span class="op">;</span></span>
<span id="cb2-24"><a href=""></a>    <span class="op">}</span></span>
<span id="cb2-25"><a href=""></a>    <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>total<span class="op">)</span> <span class="op">/</span> scores<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb2-26"><a href=""></a><span class="op">}</span></span>
<span id="cb2-27"><a href=""></a></span>
<span id="cb2-28"><a href=""></a><span class="dt">void</span> displayScores<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-29"><a href=""></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> score <span class="op">:</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-30"><a href=""></a>        cout <span class="op">&lt;&lt;</span> score <span class="op">&lt;&lt;</span> <span class="st">" "</span><span class="op">;</span></span>
<span id="cb2-31"><a href=""></a>    <span class="op">}</span></span>
<span id="cb2-32"><a href=""></a>    cout <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb2-33"><a href=""></a><span class="op">}</span></span>
<span id="cb2-34"><a href=""></a></span>
<span id="cb2-35"><a href=""></a><span class="dt">int</span> findHighest<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-36"><a href=""></a>    <span class="dt">int</span> highest <span class="op">=</span> scores<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-37"><a href=""></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> score <span class="op">:</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-38"><a href=""></a>        <span class="cf">if</span> <span class="op">(</span>score <span class="op">&gt;</span> highest<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-39"><a href=""></a>            highest <span class="op">=</span> score<span class="op">;</span></span>
<span id="cb2-40"><a href=""></a>        <span class="op">}</span></span>
<span id="cb2-41"><a href=""></a>    <span class="op">}</span></span>
<span id="cb2-42"><a href=""></a>    <span class="cf">return</span> highest<span class="op">;</span></span>
<span id="cb2-43"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Now look at this code - it’s doing exactly the same thing as that messy spaghetti code we saw earlier, but it’s so much better! <pause> Notice how main() is clean and readable - it tells a story: display the scores, show the average, show the highest score. Each of these operations is delegated to a specialized function. <slow down=""> Look at the function declarations at the top - these tell the compiler what functions exist and what they do. Then below main, we have the actual implementations. Each function has one clear job: calculateAverage adds up scores and divides by the count, displayScores prints them out, and findHighest finds the maximum value. Compare this to the goto-based spaghetti code - isn’t this so much clearer? You can read it top to bottom and understand exactly what’s happening. This is the power of function-centric architecture.
</slow></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="use-cases" class="slide level2">
<h2>Use Cases</h2>
<ul>
<li>Introductory programming courses</li>
<li>Simple, straightforward problems</li>
<li>Mathematical computations</li>
<li>Small to medium programs</li>
<li>Scripts and utilities</li>
</ul>
<aside class="notes">
<p>
Function-centric architecture works great for certain types of programs. It’s perfect for learning programming, which is why we’re using it in this course. It’s also well-suited for straightforward problems where the solution is a series of steps, mathematical computations where you need to perform calculations, and small to medium-sized programs and utilities. When your program is primarily about performing a sequence of operations on data, function-centric architecture is an excellent choice.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="anti-use-cases" class="slide level2">
<h2>Anti-Use Cases</h2>
<ul>
<li>Large, complex systems</li>
<li>Programs modeling real-world entities</li>
<li>Systems requiring data encapsulation</li>
<li>Projects with many developers</li>
</ul>
<aside class="notes">
<p>
However, function-centric architecture has its limitations. For large, complex systems with hundreds of thousands of lines of code, it can become difficult to manage all the functions and data flowing between them. When you’re modeling real-world entities - like customers, orders, and products - object-oriented programming often provides a more natural fit. Similarly, if you need strong data encapsulation where data is protected and can only be accessed through specific interfaces, objects work better. And on large projects with many developers, the encapsulation and modularity of object-oriented design helps teams work independently without stepping on each other’s toes. <pause> But for now, function-centric architecture will serve us well as we learn the fundamentals of structured programming.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="conceptual-process" class="slide level2">
<h2>Conceptual Process</h2>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li>Here’s some code</li>
</ul>
</div><div class="column" style="width:50%;">
<p><img data-src="topics/function_centric_architecture/images/cb1.png" style="margin-top: -3em;;width:50.0%"></p>
</div></div>
<aside class="notes">
<p>
Let me show you the thought process behind creating functions. Imagine you’re writing code and you have a bunch of statements all mixed together in your main function. The diagram on your right shows this visually - just a block of code statements.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li>Say several sections repeat</li>
<li>This duplicate code will diverge at some point.</li>
</ul>
</div><div class="column" style="width:50%;">
<p><img data-src="topics/function_centric_architecture/images/cb2.png" style="width:50.0%"></p>
</div></div>
<aside class="notes">
<p>
Now notice on your screen - several sections of this code are repeated in different places, shown here with matching colors. This duplication is a red flag. Even if the code is identical now, duplicate code tends to diverge over time. Someone will update one copy but forget to update the other, and suddenly you have bugs and inconsistencies. This is where functions come to the rescue.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="solution" class="slide level2">
<h2>Solution</h2>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li>Pull the duplicated code out.</li>
<li>Give it a name.</li>
<li>Call the duplicated code in the main part of the program.</li>
</ul>
</div><div class="column" style="width:50%;">
<p><img data-src="topics/function_centric_architecture/images/cb3.png" style="width:50.0%"></p>
</div></div>
<aside class="notes">
<p>
The solution is to extract that duplicated code, give it a meaningful name, and then call that function wherever you need that behavior. Look at the diagram - we’ve pulled out the repeated sections into separate functions, and now the main code just calls those functions by name. Now there’s only one copy of each piece of logic. If you need to change how something works, you change it in one place and all uses of that function automatically get the update. This is the DRY principle - Don’t Repeat Yourself - one of the most important principles in programming.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="full-solution" class="slide level2">
<h2>Full Solution</h2>
<pre><code>
statement
statement
function_name
statement
function_name
statement
statement
function_name

function_name
statement
statement
</code></pre>
<aside class="notes">
<p>
Here’s the conceptual view of our refactored code. The main part of the program is now a clean sequence of statements and function calls. Below that, we have the function definitions with their implementation details. This gives us a nice separation - the main logic reads like a high-level outline, and the details are tucked away in their named functions. This makes code much easier to understand, maintain, and debug.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>
<section id="coding-functions" class="title-slide slide level1 center">
<h1>Coding Functions</h1>
<aside class="notes">
<p>
<pause> Now that we understand the philosophy behind functions, let’s learn the mechanics - how do we actually create and use functions in C++?
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="how-we-create-functions" class="slide level2">
<h2>How We Create Functions</h2>
<aside class="notes">
<p>
When looking for opportunities to create functions, a good place to start is with clutter code - things like headers and footers, prompts, and housekeeping tasks that don’t relate to your main logic. These are perfect candidates to extract into functions. Let’s see how we create a function.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="creating-a-function" class="slide level2">
<h2>Creating a Function</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href=""></a><span class="co">// 6-1.cpp -- Demo of functions</span></span>
<span id="cb4-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-4"><a href=""></a></span>
<span id="cb4-5"><a href=""></a><span class="co">// Function Prototype</span></span>
<span id="cb4-6"><a href=""></a><span class="dt">void</span> DisplayMessage<span class="op">();</span></span>
<span id="cb4-7"><a href=""></a></span>
<span id="cb4-8"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span>                          <span class="co">// function 1</span></span>
<span id="cb4-9"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb4-10"><a href=""></a>    DisplayMessage<span class="op">();</span>                 <span class="co">// call function 2</span></span>
<span id="cb4-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main() again</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb4-12"><a href=""></a></span>
<span id="cb4-13"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-14"><a href=""></a><span class="op">}</span></span>
<span id="cb4-15"><a href=""></a></span>
<span id="cb4-16"><a href=""></a><span class="dt">void</span> DisplayMessage<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-17"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from DisplayMessage()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb4-18"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Here’s a complete example of a simple function. Let me walk you through the three key parts. <pause> At the top, after our includes, we have the function prototype on line 6 - that’s the declaration that tells the compiler “a function called DisplayMessage exists.” <pause> In main, we call that function on line 10. <pause> And then at the bottom, starting at line 16, we have the actual function definition - the implementation that contains the code to execute. Notice the function is defined below main. This is the standard style in C++ when using function prototypes.
</pause></pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-prototype" class="slide level2">
<h2>Function Prototype</h2>
<p>“<em>A function prototype eliminates the need to place a function definition before all calls to the function.</em>”</p>
<p>– Textbook, p.332.</p>
<aside class="notes">
<p>
The function prototype is crucial to understand. <slow down=""> C++ reads your code from top to bottom, and it needs to know about a function before you can call it. Without prototypes, you’d have to define every function before main, which means main would be at the bottom of your file. Prototypes solve this problem - they tell the compiler “trust me, this function exists, here’s its signature, I’ll give you the full definition later.” This lets us write our code in a more logical order, with main at the top where we naturally start reading.
</slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-prototype-example" class="slide level2">
<h2>Function Prototype Example</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5" data-code-line-numbers="6|16"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href=""></a><span class="co">// 6-1.cpp -- Demo of functions</span></span>
<span id="cb5-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-4"><a href=""></a></span>
<span id="cb5-5"><a href=""></a><span class="co">// Function Prototype</span></span>
<span id="cb5-6"><a href=""></a><span class="dt">void</span> DisplayMessage<span class="op">();</span></span>
<span id="cb5-7"><a href=""></a></span>
<span id="cb5-8"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span>                 <span class="co">// function 1</span></span>
<span id="cb5-9"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb5-10"><a href=""></a>    DisplayMessage<span class="op">();</span>        <span class="co">// call function 2</span></span>
<span id="cb5-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main() again</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb5-12"><a href=""></a></span>
<span id="cb5-13"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-14"><a href=""></a><span class="op">}</span></span>
<span id="cb5-15"><a href=""></a></span>
<span id="cb5-16"><a href=""></a><span class="dt">void</span> DisplayMessage<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-17"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from DisplayMessage()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb5-18"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Notice on line 6 - this is the prototype. It looks just like the function definition, but it ends with a semicolon and has no body. <pause> Then look down at line 16 - this is the full definition with the actual implementation in curly braces. The prototype up top makes it possible to call the function from main even though the definition comes later in the file.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="wheres-the-code" class="slide level2">
<h2>Where’s the code?</h2>
<div class="columns">
<div class="column" style="width:65%;">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6" data-code-line-numbers="16-18"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href=""></a><span class="co">// 6-1.cpp -- Demo of functions</span></span>
<span id="cb6-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-4"><a href=""></a></span>
<span id="cb6-5"><a href=""></a><span class="co">// Function Prototype</span></span>
<span id="cb6-6"><a href=""></a><span class="dt">void</span> DisplayMessage<span class="op">();</span></span>
<span id="cb6-7"><a href=""></a></span>
<span id="cb6-8"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span>                 <span class="co">// function 1</span></span>
<span id="cb6-9"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb6-10"><a href=""></a>    DisplayMessage<span class="op">();</span>        <span class="co">// call function 2</span></span>
<span id="cb6-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main() again</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb6-12"><a href=""></a></span>
<span id="cb6-13"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-14"><a href=""></a><span class="op">}</span></span>
<span id="cb6-15"><a href=""></a></span>
<span id="cb6-16"><a href=""></a><span class="dt">void</span> DisplayMessage<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-17"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from DisplayMessage()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb6-18"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div><div class="column" style="width:35%;">
<p>Notice how the function itself is BELOW main()</p>
</div></div>
<aside class="notes">
<p>
Look at lines 16 through 18 - the actual function body is below main. This is the conventional style in C++ and it has advantages: when someone opens your file, they see main first, which tells them what the program does at a high level. The implementation details of each function are below, where they don’t clutter up the main logic. Think of it like reading a book with footnotes - the main narrative flows smoothly, and the details are available when you need them.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-location" class="slide level2">
<h2>Function Location</h2>
<p>A function can go above or below main().</p>
<p>The style in this language is to place them below main() AND use function prototypes.</p>
<aside class="notes">
<p>
Students often ask: “Can’t I just put the function above main and skip the prototype?” Yes, technically that works. But the established C++ style is to use prototypes and place definitions below main. This keeps the high-level logic at the top of the file where you naturally start reading. Following language conventions makes your code more readable to other programmers and shows you’re writing professional, idiomatic code.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-calls-in-a-function" class="slide level2">
<h2>Function Calls in a Function</h2>
<div class="columns">
<div class="column" style="width:75%;">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7" data-code-line-numbers="14|15|16|8|9|10|4|5|11|17"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-3"><a href=""></a></span>
<span id="cb7-4"><a href=""></a><span class="dt">void</span> Deeper<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-5"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Now inside function Deeper()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb7-6"><a href=""></a><span class="op">}</span></span>
<span id="cb7-7"><a href=""></a></span>
<span id="cb7-8"><a href=""></a><span class="dt">void</span> Deep<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-9"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from Deep()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb7-10"><a href=""></a>    Deeper<span class="op">();</span></span>
<span id="cb7-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Now back in Deep() again</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb7-12"><a href=""></a><span class="op">}</span></span>
<span id="cb7-13"><a href=""></a></span>
<span id="cb7-14"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span>                 <span class="co">// function 1</span></span>
<span id="cb7-15"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb7-16"><a href=""></a>    Deep<span class="op">();</span></span>
<span id="cb7-17"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main() again</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb7-18"><a href=""></a></span>
<span id="cb7-19"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-20"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div><div class="column" style="width:25%;">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="topics/functions/images/funcDemo2Out.png"></p>
<figcaption>Output</figcaption>
</figure>
</div>
</div></div>
<aside class="notes">
<p>
Functions can call other functions - this is where the power of structured programming really shines. <slow down=""> Let’s trace through this execution step by step. Line 14 prints “Hello from main.” Line 15 calls Deep(). <pause> Execution jumps to line 8, which prints “Hello from Deep.” Line 9 calls Deeper(). <pause> Execution jumps to line 4, which prints “Now inside function Deeper.” Line 5 ends the function, so we return to line 10. <pause> Line 10 prints “Now back in Deep.” Line 11 ends Deep(), so we return to line 16. <pause> Line 16 prints “Hello from main again.” Look at the output on the right - this is exactly what we see. This call chain - main calls Deep, Deep calls Deeper - is fundamental to how we build complex programs from simple functions.
</pause></pause></pause></pause></slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="with-function-prototype" class="slide level2">
<h2>with Function Prototype</h2>
<div class="columns">
<div class="column" style="width:75%;">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8" data-code-line-numbers="10|11|17|18|19|23|24|20|12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href=""></a><span class="co">// 6-4.cpp -- Functions calling functions</span></span>
<span id="cb8-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb8-4"><a href=""></a></span>
<span id="cb8-5"><a href=""></a><span class="co">// Function Prototype</span></span>
<span id="cb8-6"><a href=""></a><span class="dt">void</span> Deep<span class="op">();</span></span>
<span id="cb8-7"><a href=""></a><span class="dt">void</span> Deeper<span class="op">();</span></span>
<span id="cb8-8"><a href=""></a></span>
<span id="cb8-9"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-10"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb8-11"><a href=""></a>    Deep<span class="op">();</span></span>
<span id="cb8-12"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from main() again</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb8-13"><a href=""></a></span>
<span id="cb8-14"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-15"><a href=""></a><span class="op">}</span></span>
<span id="cb8-16"><a href=""></a></span>
<span id="cb8-17"><a href=""></a><span class="dt">void</span> Deep<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-18"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello from Deep()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb8-19"><a href=""></a>    Deeper<span class="op">();</span></span>
<span id="cb8-20"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Now back in Deep() again</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb8-21"><a href=""></a><span class="op">}</span></span>
<span id="cb8-22"><a href=""></a></span>
<span id="cb8-23"><a href=""></a><span class="dt">void</span> Deeper<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-24"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Now inside function Deeper()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb8-25"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div><div class="column" style="width:25%;">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="topics/functions/images/funcDemo2aOut.png"></p>
<figcaption>Output</figcaption>
</figure>
</div>
</div></div>
<aside class="notes">
<p>
Here’s the same program written in the proper C++ style with prototypes. Notice lines 6 and 7 declare both functions up top. Now the definitions can go in any order below main - the prototypes have already told the compiler everything it needs to know. The execution and output are identical to before, but the code organization is cleaner and more professional. This is the style you should use in your own programs.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="we-can-call-but-not-define" class="slide level2">
<h2>We can call but not define</h2>
<p>Notice we did not define a function inside another function, we just called it.</p>
<p>Defining a function inside a function is called <strong>nesting</strong> and is not allowed with functions in this language.</p>
<aside class="notes">
<p>
This is an important point that often confuses beginners: we called Deeper() from inside Deep(), but we didn’t define Deeper() inside Deep(). Defining a function inside another function is called nesting, and C++ does not allow this. All function definitions must be at the same level. <pause> You can call functions from within other functions all day long - that’s encouraged! But the definitions themselves must all be separate, top-level definitions. Students sometimes ask “Can I put one function inside another?” The answer is no - you can call it, but not define it there.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">


<img data-src="topics/functions/images/funcSketch.jpg" style="width:25.0%" class="r-stretch quarto-figure-center"><p class="caption">Output</p><aside class="notes">
<p>
Here’s a quick visual sketch showing the function call relationships. Remember, functions calling other functions is how we build complex programs from simple building blocks.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>
<section id="return-of-void" class="title-slide slide level1 center">
<h1>Return of Void</h1>
<aside class="notes">
<p>
<pause> Now we’re going to dive deeper into a special type of function - void functions. These are functions that perform actions but don’t return any value.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="remember-void" class="slide level2">
<h2>Remember void?</h2>
<p>We last saw void when we were looking at variable types.</p>
<aside class="notes">
<p>
You may remember seeing void before when we studied variable types. It was unusual because it’s a type, but we can’t actually declare variables with it. Now we’ll see where void is actually used - in functions that don’t return values.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="void-functions-in-c" class="slide level2">
<h2>Void Functions in C++</h2>
<p>Usually when we create a function, we need to pass data back and forth between the function and the calling code.</p>
<p><strong>But what if a function doesn’t need to return anything?</strong></p>
<p>That’s where <code>void</code> comes in!</p>
<aside class="notes">
<p>
We start with void functions because they’re the simplest category of functions to understand. Most functions we write will need to accept input data, process it, and return results. But sometimes a function just needs to do something - print a message, draw a line on the screen, play a sound - without computing and returning a value. These action-oriented functions use void as their return type.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="what-is-void" class="slide level2">
<h2>What is void?</h2>
<p><strong>void</strong> means “nothing” or “empty”</p>
<p>When you use <code>void</code> as a return type, you’re telling C++:</p>
<blockquote>
<p>“This function does something, but it doesn’t give back a value.”</p>
</blockquote>
<p><strong>Think of it like:</strong></p>
<ul>
<li>A light switch: It turns on a light (action), but doesn’t give you anything back</li>
<li>A printer: It prints a document (action), but doesn’t return a value</li>
</ul>
<aside class="notes">
<p>
<slow down=""> Void literally means “nothing” or “empty.” When you declare a function with void as its return type, you’re making a promise to the compiler: “This function will do something useful, but it won’t compute and return a value for you to use.” <pause> Think of everyday actions that are like this. When you flip a light switch, it turns on the light - that’s the action - but the switch doesn’t hand you anything back. When you send a document to a printer, it prints the pages, but it doesn’t return a value. These are void operations in the real world. In programming, void functions work the same way - they perform actions with side effects, but don’t produce a value you can capture or use in an expression.
</pause></slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="a-void-function" class="slide level2">
<h2>A Void Function</h2>
<div class="columns">
<div class="column" style="width:75%;">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-3"><a href=""></a></span>
<span id="cb9-4"><a href=""></a><span class="dt">void</span> greet<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-5"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello, World!"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb9-6"><a href=""></a><span class="op">}</span></span>
<span id="cb9-7"><a href=""></a></span>
<span id="cb9-8"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-9"><a href=""></a>    greet<span class="op">();</span>  <span class="co">// Call the function</span></span>
<span id="cb9-10"><a href=""></a></span>
<span id="cb9-11"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-12"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div><div class="column" style="width:25%;">
<p><strong>Output:</strong></p>
<pre><code>Hello, World!</code></pre>
</div></div>
<p><strong>Notice:</strong></p>
<ul>
<li><code>void</code> means no return value</li>
<li>No <code>return</code> statement needed (or use <code>return;</code> with nothing after it)</li>
<li>Just call the function by its name with <code>()</code></li>
</ul>
<aside class="notes">
<p>
Here’s our first void function example. Look at line 4 - the function is declared with void as the return type. The function body simply prints “Hello, World!” Notice there’s no return statement - with void functions, you don’t need one. The function just runs its code and when it reaches the closing brace, it automatically returns control to the caller. In main on line 9, we call the function by writing its name followed by parentheses. We don’t assign the result to anything because there is no result - it’s void. The function just does its job of printing and then we move on to the next statement.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="void-function-syntax" class="slide level2">
<h2>Void Function Syntax</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href=""></a><span class="dt">void</span> functionName<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-2"><a href=""></a>    <span class="co">// Code to execute</span></span>
<span id="cb11-3"><a href=""></a>    <span class="co">// No return statement required</span></span>
<span id="cb11-4"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Parts:</strong></p>
<ul>
<li><code>void</code> - The return type (nothing returned)</li>
<li><code>functionName</code> - The name you choose</li>
<li><code>()</code> - Parentheses (empty for now)</li>
<li><code>{ }</code> - Curly braces contain the function body</li>
</ul>
<aside class="notes">
<p>
Let’s break down the anatomy of a void function. The first word, void, is the return type - it says “this function returns nothing.” Next is the function name - choose something descriptive that explains what the function does. Then we have parentheses - they’re empty in these examples, but soon we’ll learn how to put parameters inside them to pass data into the function. Finally, curly braces contain the function body - all the statements that execute when the function is called. No return statement is required since we’re not returning a value.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="example-display-a-message" class="slide level2">
<h2>Example: Display a Message</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb12-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb12-3"><a href=""></a></span>
<span id="cb12-4"><a href=""></a><span class="dt">void</span> displayWelcome<span class="op">()</span> <span class="op">{</span></span>
<span id="cb12-5"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"================================"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb12-6"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"   WELCOME TO MY PROGRAM!       "</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb12-7"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"================================"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb12-8"><a href=""></a><span class="op">}</span></span>
<span id="cb12-9"><a href=""></a></span>
<span id="cb12-10"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb12-11"><a href=""></a>    displayWelcome<span class="op">();</span></span>
<span id="cb12-12"><a href=""></a></span>
<span id="cb12-13"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Let's get started..."</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb12-14"><a href=""></a></span>
<span id="cb12-15"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-16"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Output:</strong></p>
<pre><code>================================
   WELCOME TO MY PROGRAM!
================================
Let's get started...</code></pre>
<aside class="notes">
<p>
Here’s a practical example. The displayWelcome function prints a formatted banner - three lines that create a nice header for our program. In main, we just call displayWelcome() and it does its job. This is much cleaner than having those three cout statements cluttering up main. The function name acts as a label that tells us what this code does - it displays a welcome message. This readability benefit is one of the key reasons we use functions.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="example-multiple-void-functions" class="slide level2">
<h2>Example: Multiple Void Functions</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb14-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb14-3"><a href=""></a></span>
<span id="cb14-4"><a href=""></a><span class="dt">void</span> displayHeader<span class="op">()</span></span>
<span id="cb14-5"><a href=""></a><span class="dt">void</span> displayMenu<span class="op">()</span></span>
<span id="cb14-6"><a href=""></a><span class="dt">void</span> displayFooter<span class="op">()</span></span>
<span id="cb14-7"><a href=""></a></span>
<span id="cb14-8"><a href=""></a><span class="dt">void</span> displayHeader<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-9"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"*** GRADE CALCULATOR ***"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb14-10"><a href=""></a><span class="op">}</span></span>
<span id="cb14-11"><a href=""></a></span>
<span id="cb14-12"><a href=""></a><span class="dt">void</span> displayMenu<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-13"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"1. Enter grades"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb14-14"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"2. Calculate average"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb14-15"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"3. Exit"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb14-16"><a href=""></a><span class="op">}</span></span>
<span id="cb14-17"><a href=""></a></span>
<span id="cb14-18"><a href=""></a><span class="dt">void</span> displayFooter<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-19"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"*** END OF PROGRAM ***"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb14-20"><a href=""></a><span class="op">}</span></span>
<span id="cb14-21"><a href=""></a></span>
<span id="cb14-22"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-23"><a href=""></a>    displayHeader<span class="op">();</span></span>
<span id="cb14-24"><a href=""></a>    displayMenu<span class="op">();</span></span>
<span id="cb14-25"><a href=""></a>    displayFooter<span class="op">();</span></span>
<span id="cb14-26"><a href=""></a></span>
<span id="cb14-27"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-28"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
This example shows how multiple void functions work together to create a complete program interface. Notice the three prototypes at the top, then main calls each function in sequence to build the user interface. Each function has one clear responsibility: displayHeader shows the title, displayMenu shows the options, and displayFooter shows the closing message. This separation of concerns makes the code modular - if you want to change the menu, you only edit displayMenu. If you want to enhance the header, you only edit displayHeader. Everything is organized and easy to maintain.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="why-use-void-functions" class="slide level2">
<h2>Why Use Void Functions?</h2>
<ol type="1">
<li><strong>Organize your code</strong></li>
<li><strong>Avoid repetition</strong></li>
<li><strong>Make code readable</strong></li>
</ol>
<aside class="notes">
<p>
Void functions serve three critical purposes in programming. First, they organize your code into logical chunks. Second, they help you avoid repetition by letting you write code once and call it many times. Third, they make your code more readable by replacing blocks of detailed code with a single descriptive function name. Let’s look at examples of each.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="organize-your-code" class="slide level2">
<h2>Organize your code</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href=""></a><span class="dt">void</span> displayTitle<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb15-2"><a href=""></a><span class="dt">void</span> displayMenu<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb15-3"><a href=""></a><span class="dt">void</span> displayResults<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Organization means breaking your program into logical sections. Instead of one massive main function with hundreds of lines, you have clear, named sections. When someone reads your main function, they see displayTitle, displayMenu, displayResults - they instantly understand the program’s structure without reading implementation details.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="avoid-repetition" class="slide level2">
<h2>Avoid repetition</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href=""></a><span class="dt">void</span> printLine<span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-2"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"------------------------"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb16-3"><a href=""></a><span class="op">}</span></span>
<span id="cb16-4"><a href=""></a></span>
<span id="cb16-5"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-6"><a href=""></a>    printLine<span class="op">();</span>  <span class="co">// Use multiple times</span></span>
<span id="cb16-7"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Section 1"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb16-8"><a href=""></a>    printLine<span class="op">();</span></span>
<span id="cb16-9"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Section 2"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb16-10"><a href=""></a>    printLine<span class="op">();</span></span>
<span id="cb16-11"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Avoiding repetition is crucial for maintainability. Look at this printLine function - imagine if instead of calling printLine three times, you had copied that cout statement three times. Now what happens if you want to change the line to use equals signs instead of dashes? Without the function, you’d have to find and change all three copies. With the function, you change it once and all uses automatically get the update. This is the DRY principle in action.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="make-code-readable" class="slide level2">
<h2>Make code readable</h2>
<ul>
<li><code>displayWelcomeMessage()</code> is clearer than 10 lines of cout</li>
<li>Functions act as labels for what the code does</li>
</ul>
<aside class="notes">
<p>
Readability is perhaps the most important benefit. Compare reading “displayWelcomeMessage()” versus reading through 10 lines of detailed cout statements with ASCII art and formatting. The function name tells you immediately what’s happening. The implementation details are tucked away where they don’t distract from the main logic. Good function names act as documentation - they explain what the code does in plain English. This makes code much easier to understand, maintain, and debug.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="using-return-in-void-functions" class="slide level2">
<h2>Using return in Void Functions</h2>
<p>Void functions can use <code>return</code> to exit early (no value after it):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href=""></a><span class="dt">void</span> checkAge<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-2"><a href=""></a>    <span class="dt">int</span> age <span class="op">=</span> <span class="dv">15</span><span class="op">;</span></span>
<span id="cb17-3"><a href=""></a></span>
<span id="cb17-4"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>age <span class="op">&lt;</span> <span class="dv">18</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-5"><a href=""></a>        cout <span class="op">&lt;&lt;</span> <span class="st">"Access denied."</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb17-6"><a href=""></a>        <span class="cf">return</span><span class="op">;</span>  <span class="co">// Exit function early</span></span>
<span id="cb17-7"><a href=""></a>    <span class="op">}</span></span>
<span id="cb17-8"><a href=""></a></span>
<span id="cb17-9"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Access granted."</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb17-10"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Output:</strong></p>
<pre><code>Access denied.</code></pre>
<p>The function exits at <code>return;</code> and never reaches the “Access granted” line.</p>
<aside class="notes">
<p>
Even though void functions don’t return values, they can still use the return keyword to exit early. Notice line 6 - just the word return followed by a semicolon, with no value. This immediately exits the function and returns control to the caller. Any code after that return statement won’t execute. This is useful for validation or error checking - if you detect a problem early in the function, you can return immediately rather than executing the rest of the code. Just remember: return with no value for void functions, and we’ll see later how to return values from non-void functions.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="example-clean-code-with-void-functions" class="slide level2">
<h2>Example:<br> Clean Code with Void Functions</h2>
<p><strong>Before (messy main):</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb19-2"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"=== CALCULATOR ==="</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb19-3"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"1. Add"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb19-4"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"2. Subtract"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb19-5"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Select: "</span><span class="op">;</span></span>
<span id="cb19-6"><a href=""></a>    <span class="co">// ... more code ...</span></span>
<span id="cb19-7"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"=== END ==="</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb19-8"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-9"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Look at this before picture - main is cluttered with all the display details. It’s hard to see the actual program logic because it’s buried in cout statements.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<p><strong>After (organized with void functions):</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href=""></a><span class="dt">void</span> displayTitle<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb20-2"><a href=""></a><span class="dt">void</span> displayMenu<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb20-3"><a href=""></a><span class="dt">void</span> displayFooter<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span>
<span id="cb20-4"><a href=""></a></span>
<span id="cb20-5"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb20-6"><a href=""></a>    displayTitle<span class="op">();</span></span>
<span id="cb20-7"><a href=""></a>    displayMenu<span class="op">();</span></span>
<span id="cb20-8"><a href=""></a>    <span class="co">// ... main logic ...</span></span>
<span id="cb20-9"><a href=""></a>    displayFooter<span class="op">();</span></span>
<span id="cb20-10"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-11"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Much cleaner and easier to understand!</p>
<aside class="notes">
<p>
Now look at the after version. Main reads like a table of contents: display title, display menu, do the main logic, display footer. The implementation details are hidden away in their respective functions. This is dramatically cleaner and easier to understand. When you come back to this code six months later, or when someone else reads your code, they’ll thank you for this organization. This transformation from cluttered to clean is what good function design achieves.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="summary" class="slide level2">
<h2>Summary</h2>
<p><strong>Void Functions:</strong></p>
<ul>
<li>Use <code>void</code> as return type when no value is returned</li>
<li>Perfect for displaying output or performing actions</li>
<li>Make code more organized and readable</li>
<li>Don’t use <code>return</code> with a value</li>
<li>Can’t be used in expressions or assignments</li>
</ul>
<aside class="notes">
<p>
Let’s summarize void functions. They use void as their return type because they don’t return values. They’re perfect for operations that produce side effects like displaying output or modifying global state. They make your code more organized and readable by giving meaningful names to blocks of code. Remember you can’t return a value from a void function - return must be used alone. And because void functions don’t produce values, you can’t use them in expressions or assignments like you can with functions that return values. <pause> Next, we’ll learn how to make functions more flexible by passing data into them.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>
<section id="passing-data-to-and-from-functions" class="title-slide slide level1 center">
<h1>Passing Data To and From Functions</h1>
<aside class="notes">
<p>
<pause> Now we’re ready for the really powerful stuff - passing data into functions and getting results back. This is what makes functions truly flexible and reusable.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="topics" class="slide level2">
<h2>Topics:</h2>
<ul>
<li>Understanding parameters and arguments</li>
<li>Passing data into functions</li>
<li>Returning data from functions</li>
<li>Function prototypes</li>
<li>Common mistakes and how to avoid them</li>
<li>Practical examples</li>
</ul>
<aside class="notes">
<p>
This section builds on void functions by adding the ability to pass data back and forth. We’ll learn the difference between parameters and arguments, how to send data into functions, how to get computed results back, and see practical examples that tie it all together. This is where functions become truly powerful tools for organizing complex programs.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="why-functions-need-data" class="slide level2">
<h2>Why Functions Need Data</h2>
<p>Consider this function:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href=""></a><span class="dt">void</span> displayName<span class="op">()</span> <span class="op">{</span></span>
<span id="cb21-2"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello, Alice!"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb21-3"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Problem:</strong> This only works for Alice. What about Bob or Charlie?</p>
<p><strong>Challenge:</strong> How can we make one function work for any name?</p>
<p><strong>Solution:</strong> Give functions the ability to receive and process different data.</p>
<aside class="notes">
<p>
<slow down=""> Look at this function - it greets Alice, but what if we want to greet Bob? Or Charlie? Or any of a hundred different people? Do we write a hundred different functions? Of course not! We need a way to make one flexible function that can work with different data each time it’s called. <pause> This is the fundamental problem that parameters solve. By giving functions the ability to receive data when they’re called, we make them flexible and reusable. One function can serve many different purposes depending on what data you pass to it.
</pause></slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="parameters-receiving-data" class="slide level2">
<h2>Parameters: Receiving Data</h2>
<p><strong>Parameters</strong> are variables in the function definition that receive data.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href=""></a><span class="dt">void</span> displayName<span class="op">(</span>string name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-2"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello, "</span> <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="st">"!"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb22-3"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Anatomy:</strong></p>
<ul>
<li><code>string</code> is the data type</li>
<li><code>name</code> is the parameter variable</li>
<li>Parameters exist only inside the function</li>
</ul>
<aside class="notes">
<p>
Parameters are the solution to our problem. <pause> Look at the function definition - inside the parentheses, we’ve declared a string variable called name. This is a parameter. When someone calls this function, they must provide a string value, and that value gets copied into this name parameter. Inside the function, name is just like any other variable - you can use it in expressions, print it, whatever you need. The key difference is that its value comes from the caller, not from code inside the function. <slow down=""> Also notice that parameters only exist inside the function - they’re local to that function and disappear when the function ends.
</slow></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="arguments-vs-parameters" class="slide level2">
<h2>Arguments vs Parameters</h2>
<p><strong>Parameter:</strong> Variable in the function definition (placeholder)</p>
<p><strong>Argument:</strong> Actual value passed when calling the function (real data)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb23-1"><a href=""></a><span class="dt">void</span> displayName<span class="op">(</span>string name<span class="op">)</span> <span class="op">{</span>     <span class="co">// name is a PARAMETER</span></span>
<span id="cb23-2"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello, "</span> <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="st">"!"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb23-3"><a href=""></a><span class="op">}</span></span>
<span id="cb23-4"><a href=""></a></span>
<span id="cb23-5"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-6"><a href=""></a>    displayName<span class="op">(</span><span class="st">"Alice"</span><span class="op">);</span>           <span class="co">// "Alice" is an ARGUMENT</span></span>
<span id="cb23-7"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-8"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The argument value is copied into the parameter variable.</p>
<aside class="notes">
<p>
This distinction confuses many beginners, so let me be very clear: parameters versus arguments. <pause> Look at line 1: name is the PARAMETER - it’s the variable in the function definition, like a placeholder. Now look at line 7: “Alice” is the ARGUMENT - it’s the actual value we pass when calling the function. <pause> When you call displayName(“Alice”), the argument “Alice” is copied into the parameter name. Think of parameters as the formal specification - “I need a string” - and arguments as the actual data - “here’s Alice”. Students often mix these terms up, but now you know the difference!
</pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="single-parameter-example" class="slide level2">
<h2>Single Parameter Example</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb24-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb24-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb24-3"><a href=""></a></span>
<span id="cb24-4"><a href=""></a><span class="dt">void</span> greet<span class="op">(</span>string person<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-5"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Welcome, "</span> <span class="op">&lt;&lt;</span> person <span class="op">&lt;&lt;</span> <span class="st">"!"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb24-6"><a href=""></a><span class="op">}</span></span>
<span id="cb24-7"><a href=""></a></span>
<span id="cb24-8"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb24-9"><a href=""></a>    greet<span class="op">(</span><span class="st">"Alice"</span><span class="op">);</span></span>
<span id="cb24-10"><a href=""></a>    greet<span class="op">(</span><span class="st">"Bob"</span><span class="op">);</span></span>
<span id="cb24-11"><a href=""></a>    greet<span class="op">(</span><span class="st">"Charlie"</span><span class="op">);</span></span>
<span id="cb24-12"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-13"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Output:</strong></p>
<pre><code>Welcome, Alice!
Welcome, Bob!
Welcome, Charlie!</code></pre>
<aside class="notes">
<p>
Here’s a complete example showing the power of parameters. We have one function, greet, but we call it three times with three different arguments. Each call copies its argument into the person parameter, and the function greets that person. One function, three different behaviors, all because we can pass in different data. This is the essence of reusable code - write once, use many times with different inputs.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="multiple-parameters" class="slide level2">
<h2>Multiple Parameters</h2>
<p>Functions can accept multiple pieces of data:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb26-1"><a href=""></a><span class="dt">void</span> displayProduct<span class="op">(</span>string name<span class="op">,</span> <span class="dt">double</span> price<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-2"><a href=""></a>    cout <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="st">" costs $"</span> <span class="op">&lt;&lt;</span> price <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb26-3"><a href=""></a><span class="op">}</span></span>
<span id="cb26-4"><a href=""></a></span>
<span id="cb26-5"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb26-6"><a href=""></a>    displayProduct<span class="op">(</span><span class="st">"Laptop"</span><span class="op">,</span> <span class="fl">899.99</span><span class="op">);</span></span>
<span id="cb26-7"><a href=""></a>    displayProduct<span class="op">(</span><span class="st">"Mouse"</span><span class="op">,</span> <span class="fl">24.50</span><span class="op">);</span></span>
<span id="cb26-8"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-9"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="key-rules" class="slide level2">
<h2>Key Rules</h2>
<ul>
<li>Separate parameters with commas</li>
<li>Each parameter needs a type</li>
<li>Order matters - arguments must match parameter order</li>
</ul>
<aside class="notes">
<p>
When you need multiple pieces of data, you can have multiple parameters. Notice in the function definition, we separate parameters with commas, and each parameter must have its own type specification. A common mistake: you can’t write “string name, price” - you must write “string name, double price”. Each parameter needs its type! <pause> Order is critical: when you call the function, your arguments must match the parameter order exactly. First argument goes to first parameter, second to second, and so on. Mix up the order and you’ll get compiler errors or runtime bugs. <pause> So remember: separate with commas, each gets a type, and order matters!
</pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="parameter-order-and-types" class="slide level2">
<h2>Parameter Order and Types</h2>
<p>Arguments must match parameters in <strong>order</strong> and <strong>type</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb27-1"><a href=""></a><span class="dt">void</span> displayStudent<span class="op">(</span>string name<span class="op">,</span> <span class="dt">int</span> age<span class="op">,</span> <span class="dt">double</span> gpa<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href=""></a>    cout <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="st">" is "</span> <span class="op">&lt;&lt;</span> age <span class="op">&lt;&lt;</span> <span class="st">" years old"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb27-3"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"GPA: "</span> <span class="op">&lt;&lt;</span> gpa <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb27-4"><a href=""></a><span class="op">}</span></span>
<span id="cb27-5"><a href=""></a></span>
<span id="cb27-6"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-7"><a href=""></a>    displayStudent<span class="op">(</span><span class="st">"Alice"</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="fl">3.8</span><span class="op">);</span>     <span class="co">// Correct</span></span>
<span id="cb27-8"><a href=""></a>    displayStudent<span class="op">(</span><span class="dv">20</span><span class="op">,</span> <span class="st">"Alice"</span><span class="op">,</span> <span class="fl">3.8</span><span class="op">);</span>     <span class="co">// ERROR - wrong types</span></span>
<span id="cb27-9"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-10"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Look carefully at line 11 - this is correct. We pass a string for name, an int for age, and a double for gpa. They match in both order and type. <pause> Now look at line 12 - this will cause a compiler error! We’re trying to pass an int where a string is expected, and vice versa. The compiler checks these type matches and will refuse to compile code that doesn’t match. <pause> This type checking is one of C++’s safety features - it catches mistakes before your program even runs. Always ensure your arguments match the parameters in number, order, and type!
</pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="function-prototypes" class="slide level2">
<h2>Function Prototypes</h2>
<p><strong>Problem:</strong> C++ requires functions to be defined before they’re called.</p>
<p><strong>Solution:</strong> Declare the function’s signature at the top with a <strong>prototype</strong>.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb28-1"><a href=""></a><span class="co">// Prototype (declaration) - tells compiler function exists</span></span>
<span id="cb28-2"><a href=""></a><span class="dt">void</span> displayStudent<span class="op">(</span>string name<span class="op">,</span> <span class="dt">int</span> age<span class="op">,</span> <span class="dt">double</span> gpa<span class="op">);</span></span>
<span id="cb28-3"><a href=""></a></span>
<span id="cb28-4"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-5"><a href=""></a>    displayStudent<span class="op">(</span><span class="st">"Alice"</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="fl">3.8</span><span class="op">);</span>  <span class="co">// Can call here</span></span>
<span id="cb28-6"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-7"><a href=""></a><span class="op">}</span></span>
<span id="cb28-8"><a href=""></a></span>
<span id="cb28-9"><a href=""></a><span class="co">// Definition (implementation) - actual code</span></span>
<span id="cb28-10"><a href=""></a><span class="dt">void</span> displayStudent<span class="op">(</span>string name<span class="op">,</span> <span class="dt">int</span> age<span class="op">,</span> <span class="dt">double</span> gpa<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="st">" is "</span> <span class="op">&lt;&lt;</span> age <span class="op">&lt;&lt;</span> <span class="st">" years old"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb28-12"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Function prototypes become even more important when functions have parameters. The prototype must include all the parameter types in the correct order. The prototype tells the compiler “this function exists, it takes these types of parameters in this order, and it returns this type.” Then later in the file, you provide the full definition with the implementation. <pause> Prototypes are especially important when working with multiple files - you can put prototypes in a header file that gets included everywhere, while the implementations stay in separate source files. For now, just remember: prototype at the top with parameter types, definition below main with the actual code.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="prototype-syntax" class="slide level2">
<h2>Prototype Syntax</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb29-1"><a href=""></a><span class="co">// Full prototype with parameter names (recommended)</span></span>
<span id="cb29-2"><a href=""></a><span class="dt">double</span> calculateAverage<span class="op">(</span><span class="dt">double</span> score1<span class="op">,</span> <span class="dt">double</span> score2<span class="op">,</span> <span class="dt">double</span> score3<span class="op">);</span></span>
<span id="cb29-3"><a href=""></a></span>
<span id="cb29-4"><a href=""></a><span class="co">// Parameter names optional, but less clear</span></span>
<span id="cb29-5"><a href=""></a><span class="dt">double</span> calculateAverage<span class="op">(</span><span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">double</span><span class="op">);</span></span>
<span id="cb29-6"><a href=""></a></span>
<span id="cb29-7"><a href=""></a><span class="co">// Multiple prototypes</span></span>
<span id="cb29-8"><a href=""></a><span class="dt">void</span> displayMenu<span class="op">();</span></span>
<span id="cb29-9"><a href=""></a><span class="dt">int</span> getChoice<span class="op">();</span></span>
<span id="cb29-10"><a href=""></a><span class="dt">double</span> calculateTax<span class="op">(</span><span class="dt">double</span> amount<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Common practice:</strong> Include parameter names for readability. They don’t have to match the definition’s names, but usually do.</p>
<aside class="notes">
<p>
When writing prototypes, you have a choice: you can include parameter names or just types. Technically the compiler only needs the types to check your function calls, so “double calculateAverage(double, double, double);” works. But this is much less readable than “double calculateAverage(double score1, double score2, double score3);”. <pause> The version with names is self-documenting - you can see what each parameter represents without looking at the implementation. Best practice is to include descriptive parameter names in your prototypes. They don’t have to exactly match the names in the definition, but usually they do because it would be confusing if they didn’t.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="return-values-sending-data-back" class="slide level2">
<h2>Return Values: Sending Data Back</h2>
<p><strong>So far:</strong> Functions receive data through parameters (input)</p>
<p><strong>Now:</strong> Functions can send data back through return values (output)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb30-1"><a href=""></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-2"><a href=""></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb30-3"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Key components:</strong></p>
<ul>
<li><code>int</code> is the return type</li>
<li><code>return</code> statement sends the value back</li>
<li>Return type must match the returned value</li>
</ul>
<aside class="notes">
<p>
<slow down=""> Now we complete the picture: parameters let data flow into functions, and return values let data flow back out. <pause> Look at this add function. The return type is int - this means the function promises to compute and return an integer value. Inside the function, the return statement does two things: it computes a + b, and it sends that value back to whoever called the function. <pause> The return type in the function header must match the type of value you actually return. If you say you’re returning an int, you must return an int. The compiler enforces this match. <pause> Think of parameters as inputs and return values as outputs - together they make functions powerful, flexible tools for computation.
</pause></pause></pause></slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="using-return-values" class="slide level2">
<h2>Using Return Values</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb31-1"><a href=""></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href=""></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb31-3"><a href=""></a><span class="op">}</span></span>
<span id="cb31-4"><a href=""></a></span>
<span id="cb31-5"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb31-6"><a href=""></a>    <span class="co">// Store in a variable</span></span>
<span id="cb31-7"><a href=""></a>    <span class="dt">int</span> result <span class="op">=</span> add<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb31-8"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Result: "</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb31-9"><a href=""></a></span>
<span id="cb31-10"><a href=""></a>    <span class="co">// Use directly in expression</span></span>
<span id="cb31-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Sum: "</span> <span class="op">&lt;&lt;</span> add<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb31-12"><a href=""></a></span>
<span id="cb31-13"><a href=""></a>    <span class="co">// Pass to another function</span></span>
<span id="cb31-14"><a href=""></a>    cout <span class="op">&lt;&lt;</span> add<span class="op">(</span><span class="dv">5</span><span class="op">,</span> add<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">))</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb31-15"><a href=""></a></span>
<span id="cb31-16"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb31-17"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Return values are incredibly flexible - you can use them in multiple ways. <pause> Most commonly, you store the result in a variable, like line 8 does. <pause> Or you can use the function call directly in an expression, like line 11 - the function executes, returns its value, and that value gets inserted right into the expression. <pause> You can even nest function calls, like line 14. <slow down=""> Let’s trace this: first add(2, 3) executes and returns 5. Then that 5 becomes an argument to the outer add call, so we’re computing add(5, 5), which returns 10. Then 10 gets printed. This demonstrates function composition - using the output of one function as the input to another. This is a powerful technique for building complex computations from simple functions.
</slow></pause></pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="return-type-must-match" class="slide level2">
<h2>Return Type Must Match</h2>
<p>The return statement must match the function’s return type:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb32-1"><a href=""></a><span class="dt">int</span> getValue<span class="op">()</span> <span class="op">{</span></span>
<span id="cb32-2"><a href=""></a>    <span class="cf">return</span> <span class="fl">3.14</span><span class="op">;</span>        <span class="co">// </span><span class="al">WARNING</span><span class="co"> - truncated to 3</span></span>
<span id="cb32-3"><a href=""></a><span class="op">}</span></span>
<span id="cb32-4"><a href=""></a></span>
<span id="cb32-5"><a href=""></a><span class="dt">double</span> getNumber<span class="op">()</span> <span class="op">{</span></span>
<span id="cb32-6"><a href=""></a>    <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span>          <span class="co">// OK - converts to 42.0</span></span>
<span id="cb32-7"><a href=""></a><span class="op">}</span></span>
<span id="cb32-8"><a href=""></a></span>
<span id="cb32-9"><a href=""></a>string getName<span class="op">()</span> <span class="op">{</span></span>
<span id="cb32-10"><a href=""></a>    <span class="cf">return</span> <span class="dv">123</span><span class="op">;</span>         <span class="co">// ERROR - cannot convert int to string</span></span>
<span id="cb32-11"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Rule:</strong> The compiler will error or warn if types don’t match or convert properly.</p>
<aside class="notes">
<p>
The compiler is strict about return types matching. <pause> In the first example, we’re returning 3.14 from a function declared to return int. The compiler will truncate it to 3 and usually give you a warning about losing precision. <pause> In the second example, returning 42 from a double function is fine - int converts safely to double as 42.0. <pause> In the third example, trying to return an int from a string function is a hard error - there’s no automatic conversion from int to string. <pause> The lesson is: pay attention to your return types and make sure what you return matches what you declared. The compiler’s type checking is trying to help you avoid bugs.
</pause></pause></pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="multiple-return-statements" class="slide level2">
<h2>Multiple Return Statements</h2>
<p>Functions can have multiple returns, but only one executes:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb33-1"><a href=""></a><span class="dt">char</span> getLetterGrade<span class="op">(</span><span class="dt">int</span> score<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-2"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>score <span class="op">&gt;=</span> <span class="dv">90</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-3"><a href=""></a>        <span class="cf">return</span> <span class="ch">'A'</span><span class="op">;</span></span>
<span id="cb33-4"><a href=""></a>    <span class="op">}</span></span>
<span id="cb33-5"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>score <span class="op">&gt;=</span> <span class="dv">80</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-6"><a href=""></a>        <span class="cf">return</span> <span class="ch">'B'</span><span class="op">;</span></span>
<span id="cb33-7"><a href=""></a>    <span class="op">}</span></span>
<span id="cb33-8"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>score <span class="op">&gt;=</span> <span class="dv">70</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-9"><a href=""></a>        <span class="cf">return</span> <span class="ch">'C'</span><span class="op">;</span></span>
<span id="cb33-10"><a href=""></a>    <span class="op">}</span></span>
<span id="cb33-11"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>score <span class="op">&gt;=</span> <span class="dv">60</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-12"><a href=""></a>        <span class="cf">return</span> <span class="ch">'D'</span><span class="op">;</span></span>
<span id="cb33-13"><a href=""></a>    <span class="op">}</span></span>
<span id="cb33-14"><a href=""></a>    <span class="cf">return</span> <span class="ch">'F'</span><span class="op">;</span></span>
<span id="cb33-15"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Important:</strong> Once a return executes, the function immediately exits.</p>
<aside class="notes">
<p>
Functions can have multiple return statements - this is common when you have different cases or conditions. <slow down=""> But here’s the key: once any return executes, the function immediately exits. The rest of the code doesn’t run. <pause> Trace through this grading function: if the score is 92, the first if condition is true, so we return ‘A’ and exit immediately. The other if statements never even execute. <pause> If the score is 75, the first two ifs are false, the third is true, so we return ‘C’ and exit. <pause> If the score is 50, all the ifs are false, so we reach the final return statement and return ‘F’. <pause> This pattern of multiple returns is very common for decision-making functions. Just remember: first return that executes ends the function.
</pause></pause></pause></pause></slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="round-trip-method" class="slide level2">
<h2>Round-Trip Method</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb34-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb34-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iomanip&gt;</span></span>
<span id="cb34-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb34-4"><a href=""></a></span>
<span id="cb34-5"><a href=""></a><span class="dt">int</span> CalcYears<span class="op">(</span>boolean<span class="op">);</span></span>
<span id="cb34-6"><a href=""></a></span>
<span id="cb34-7"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb34-8"><a href=""></a>    <span class="dt">int</span> age <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb34-9"><a href=""></a></span>
<span id="cb34-10"><a href=""></a>    age <span class="op">=</span> CalcYears<span class="op">(</span><span class="kw">true</span><span class="op">);</span></span>
<span id="cb34-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> age <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb34-12"><a href=""></a><span class="op">}</span></span>
<span id="cb34-13"><a href=""></a></span>
<span id="cb34-14"><a href=""></a><span class="dt">int</span> CalcYears<span class="op">(</span>boolean isDog<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-15"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>isDog<span class="op">)</span> <span class="cf">return</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb34-16"><a href=""></a>    <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb34-17"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
<slow down=""> Now let me show you what I call the round-trip method - this is THE most important pattern you’ll learn today. Look at line 7 in main: we declare age and initialize it to zero. Line 9 is where the magic happens - we call CalcYears with the argument true, and assign the return value to age. <pause> Let’s trace the round trip: execution jumps to line 14, the parameter isDog receives true. Line 15 checks if isDog is true - it is, so we return 7. That 7 travels back to line 9 and gets stored in age. Line 10 prints age, which is now 7. <pause> <slow down=""> This pattern - send data out through arguments, get results back through return values - is absolutely fundamental. You’ll use this constantly. Data makes a round trip: out to the function, back with a result. Master this and you master function-based programming!
</slow></pause></pause></slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">


<img data-src="topics/function_data_to_and_fro/images/round_trip_method.png" style="width:5.0%" class="r-stretch"><aside class="notes">
<p>
This diagram visually shows the round trip: data flows from the caller into the function through parameters, the function computes a result, and that result flows back to the caller through the return value. This bidirectional data flow is what makes functions so powerful.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="example-temperature-conversion" class="slide level2">
<h2>Example: Temperature Conversion</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb35-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iomanip&gt;</span></span>
<span id="cb35-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb35-4"><a href=""></a></span>
<span id="cb35-5"><a href=""></a><span class="dt">double</span> celsiusToFahrenheit<span class="op">(</span><span class="dt">double</span> celsius<span class="op">);</span>  <span class="co">// Prototype</span></span>
<span id="cb35-6"><a href=""></a></span>
<span id="cb35-7"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb35-8"><a href=""></a>    <span class="dt">double</span> tempC <span class="op">=</span> <span class="fl">25.0</span><span class="op">;</span></span>
<span id="cb35-9"><a href=""></a>    <span class="dt">double</span> tempF <span class="op">=</span> celsiusToFahrenheit<span class="op">(</span>tempC<span class="op">);</span></span>
<span id="cb35-10"><a href=""></a></span>
<span id="cb35-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> fixed <span class="op">&lt;&lt;</span> setprecision<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb35-12"><a href=""></a>    cout <span class="op">&lt;&lt;</span> tempC <span class="op">&lt;&lt;</span> <span class="st">"°C = "</span> <span class="op">&lt;&lt;</span> tempF <span class="op">&lt;&lt;</span> <span class="st">"°F"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb35-13"><a href=""></a></span>
<span id="cb35-14"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-15"><a href=""></a><span class="op">}</span></span>
<span id="cb35-16"><a href=""></a></span>
<span id="cb35-17"><a href=""></a><span class="dt">double</span> celsiusToFahrenheit<span class="op">(</span><span class="dt">double</span> celsius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-18"><a href=""></a>    <span class="cf">return</span> <span class="op">(</span>celsius <span class="op">*</span> <span class="fl">9.0</span> <span class="op">/</span> <span class="fl">5.0</span><span class="op">)</span> <span class="op">+</span> <span class="fl">32.0</span><span class="op">;</span></span>
<span id="cb35-19"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Output:</strong> <code>25.0°C = 77.0°F</code></p>
<aside class="notes">
<p>
Here’s a practical example of the round-trip method. We have a temperature in Celsius stored in tempC. We call celsiusToFahrenheit, passing tempC as the argument. The function receives it in the celsius parameter, performs the conversion calculation, and returns the Fahrenheit value. We capture that return value in tempF. Then we print both temperatures. <pause> This is a perfect example of functional decomposition - we’ve extracted the conversion formula into its own function with a descriptive name. Now we can convert temperatures anywhere in our program just by calling this function. Clean, reusable, self-documenting code.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="example-grade-determination" class="slide level2">
<h2>Example: Grade Determination</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb36-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb36-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb36-3"><a href=""></a></span>
<span id="cb36-4"><a href=""></a><span class="dt">char</span> determineGrade<span class="op">(</span><span class="dt">double</span> average<span class="op">);</span>  <span class="co">// Prototype</span></span>
<span id="cb36-5"><a href=""></a></span>
<span id="cb36-6"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb36-7"><a href=""></a>    <span class="dt">char</span> grade <span class="op">=</span> determineGrade<span class="op">(</span><span class="fl">87.5</span><span class="op">);</span></span>
<span id="cb36-8"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Grade: "</span> <span class="op">&lt;&lt;</span> grade <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb36-9"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb36-10"><a href=""></a><span class="op">}</span></span>
<span id="cb36-11"><a href=""></a></span>
<span id="cb36-12"><a href=""></a><span class="dt">char</span> determineGrade<span class="op">(</span><span class="dt">double</span> average<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-13"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>average <span class="op">&gt;=</span> <span class="dv">90</span><span class="op">)</span> <span class="cf">return</span> <span class="ch">'A'</span><span class="op">;</span></span>
<span id="cb36-14"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>average <span class="op">&gt;=</span> <span class="dv">80</span><span class="op">)</span> <span class="cf">return</span> <span class="ch">'B'</span><span class="op">;</span></span>
<span id="cb36-15"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>average <span class="op">&gt;=</span> <span class="dv">70</span><span class="op">)</span> <span class="cf">return</span> <span class="ch">'C'</span><span class="op">;</span></span>
<span id="cb36-16"><a href=""></a>    <span class="cf">if</span> <span class="op">(</span>average <span class="op">&gt;=</span> <span class="dv">60</span><span class="op">)</span> <span class="cf">return</span> <span class="ch">'D'</span><span class="op">;</span></span>
<span id="cb36-17"><a href=""></a>    <span class="cf">return</span> <span class="ch">'F'</span><span class="op">;</span></span>
<span id="cb36-18"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Output:</strong> <code>Grade: B</code></p>
<aside class="notes">
<p>
Here’s another example showing multiple return statements. The determineGrade function takes a numeric average and returns a letter grade character. Notice how clean the logic is with multiple returns - we check each grade threshold and immediately return if we match. For an average of 87.5, the first two conditions are true, so we return ‘B’ and exit. This is efficient and readable. The round-trip is clear: we send 87.5 in, get ‘B’ back, store it in grade, and print it.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="example-grade-calculator" class="slide level2">
<h2>Example: Grade Calculator</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb37"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb37-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb37-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb37-3"><a href=""></a></span>
<span id="cb37-4"><a href=""></a><span class="co">// Prototypes</span></span>
<span id="cb37-5"><a href=""></a><span class="dt">double</span> calculateAverage<span class="op">(</span><span class="dt">int</span> s1<span class="op">,</span> <span class="dt">int</span> s2<span class="op">,</span> <span class="dt">int</span> s3<span class="op">);</span></span>
<span id="cb37-6"><a href=""></a><span class="dt">char</span> determineGrade<span class="op">(</span><span class="dt">double</span> average<span class="op">);</span></span>
<span id="cb37-7"><a href=""></a><span class="dt">void</span> displayResults<span class="op">(</span>string name<span class="op">,</span> <span class="dt">double</span> avg<span class="op">,</span> <span class="dt">char</span> grade<span class="op">);</span></span>
<span id="cb37-8"><a href=""></a></span>
<span id="cb37-9"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb37-10"><a href=""></a>    string student <span class="op">=</span> <span class="st">"Alice"</span><span class="op">;</span></span>
<span id="cb37-11"><a href=""></a>    <span class="dt">double</span> avg <span class="op">=</span> calculateAverage<span class="op">(</span><span class="dv">85</span><span class="op">,</span> <span class="dv">92</span><span class="op">,</span> <span class="dv">88</span><span class="op">);</span></span>
<span id="cb37-12"><a href=""></a>    <span class="dt">char</span> grade <span class="op">=</span> determineGrade<span class="op">(</span>avg<span class="op">);</span></span>
<span id="cb37-13"><a href=""></a>    displayResults<span class="op">(</span>student<span class="op">,</span> avg<span class="op">,</span> grade<span class="op">);</span></span>
<span id="cb37-14"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-15"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Output:</strong></p>
<pre><code>Alice's average: 88.3333
Letter grade: B</code></pre>
<aside class="notes">
<p>
This example brings everything together - the complete workflow of a well-designed program! <pause> Look at the prototypes: calculateAverage takes three scores and returns a double, determineGrade takes a double and returns a char, and displayResults is void taking multiple parameters. Now follow the flow in main: line 11 calculates the average, returning 88.333 which we store in avg. Line 12 calls determineGrade with that average, returning ‘B’ stored in grade. Line 13 calls displayResults to show everything. <pause> This is beautiful organization: main coordinates the high-level workflow by calling specialized functions, each function does one job well, and together they solve the complete problem. This IS structured, function-centric programming! Each function is simple because it has one clear job - calculateAverage adds and divides, determineGrade checks thresholds, displayResults formats output. This is how you should structure your programs!
</pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>
<section id="whats-the-output" class="title-slide slide level1 center">
<h1>What’s the Output?</h1>
<aside class="notes">
<p>
<pause> Now let’s test your understanding with an exercise. This is a chance to trace through code and predict what it will print.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="exercise-goals" class="slide level2">
<h2>Exercise Goals</h2>
<ul>
<li>Review of code syntax</li>
<li>Check understanding of syntax</li>
</ul>
<aside class="notes">
<p>
The goal of this exercise is twofold: first, to review and reinforce the syntax we’ve learned - function prototypes, function calls, parameters, and return values. Second, to check your understanding by having you trace through execution and predict output. This kind of code-reading skill is essential for debugging and understanding programs.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="what-to-do" class="slide level2">
<h2>What to Do</h2>
<ul>
<li>Using the given code …</li>
<li>Compute the output</li>
</ul>
<aside class="notes">
<p>
Your task is simple: read through the code carefully, trace the execution flow, and determine what will be printed. Think about what values get passed to parameters, what gets computed, and what gets returned.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="whats-the-output-1" class="slide level2">
<h2>What’s the Output?</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb39"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb39-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb39-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb39-3"><a href=""></a></span>
<span id="cb39-4"><a href=""></a><span class="dt">double</span> calculateArea<span class="op">(</span><span class="dt">double</span> radius<span class="op">);</span></span>
<span id="cb39-5"><a href=""></a></span>
<span id="cb39-6"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb39-7"><a href=""></a>    <span class="dt">double</span> radius <span class="op">=</span> <span class="fl">5.0</span><span class="op">;</span></span>
<span id="cb39-8"><a href=""></a>    <span class="dt">double</span> area <span class="op">=</span> calculateArea<span class="op">(</span>radius<span class="op">);</span></span>
<span id="cb39-9"><a href=""></a></span>
<span id="cb39-10"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Radius: "</span> <span class="op">&lt;&lt;</span> radius <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb39-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Area: "</span> <span class="op">&lt;&lt;</span> area <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb39-12"><a href=""></a></span>
<span id="cb39-13"><a href=""></a>    <span class="dt">double</span> newRadius <span class="op">=</span> <span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb39-14"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"New area: "</span> <span class="op">&lt;&lt;</span> calculateArea<span class="op">(</span>newRadius<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb39-15"><a href=""></a></span>
<span id="cb39-16"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-17"><a href=""></a><span class="op">}</span></span>
<span id="cb39-18"><a href=""></a></span>
<span id="cb39-19"><a href=""></a><span class="dt">double</span> calculateArea<span class="op">(</span><span class="dt">double</span> radius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-20"><a href=""></a>    <span class="cf">return</span> <span class="fl">3.14</span> <span class="op">*</span> radius <span class="op">*</span> radius<span class="op">;</span></span>
<span id="cb39-21"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
<pause> Take a moment to read through this code and think about what it will output. <pause> Notice we have a calculateArea function that computes the area of a circle given a radius. In main, we call it twice with different radii. <pause> Can you determine what will be printed? Think it through before we reveal the answer on the next slide.
</pause></pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="columns">
<div class="column" style="width:75%;">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb40-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb40-2"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb40-3"><a href=""></a></span>
<span id="cb40-4"><a href=""></a><span class="dt">double</span> calculateArea<span class="op">(</span><span class="dt">double</span> radius<span class="op">);</span></span>
<span id="cb40-5"><a href=""></a></span>
<span id="cb40-6"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb40-7"><a href=""></a>    <span class="dt">double</span> radius <span class="op">=</span> <span class="fl">5.0</span><span class="op">;</span></span>
<span id="cb40-8"><a href=""></a>    <span class="dt">double</span> area <span class="op">=</span> calculateArea<span class="op">(</span>radius<span class="op">);</span></span>
<span id="cb40-9"><a href=""></a></span>
<span id="cb40-10"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Radius: "</span> <span class="op">&lt;&lt;</span> radius <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb40-11"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Area: "</span> <span class="op">&lt;&lt;</span> area <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb40-12"><a href=""></a></span>
<span id="cb40-13"><a href=""></a>    <span class="dt">double</span> newRadius <span class="op">=</span> <span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb40-14"><a href=""></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"New area: "</span> <span class="op">&lt;&lt;</span> calculateArea<span class="op">(</span>newRadius<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb40-15"><a href=""></a></span>
<span id="cb40-16"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb40-17"><a href=""></a><span class="op">}</span></span>
<span id="cb40-18"><a href=""></a></span>
<span id="cb40-19"><a href=""></a><span class="dt">double</span> calculateArea<span class="op">(</span><span class="dt">double</span> radius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-20"><a href=""></a>    <span class="cf">return</span> <span class="fl">3.14</span> <span class="op">*</span> radius <span class="op">*</span> radius<span class="op">;</span></span>
<span id="cb40-21"><a href=""></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div><div class="column" style="width:25%;">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb41-1"><a href=""></a></span>
<span id="cb41-2"><a href=""></a>Radius<span class="op">:</span> <span class="dv">5</span></span>
<span id="cb41-3"><a href=""></a>Area<span class="op">:</span> <span class="fl">78.5</span></span>
<span id="cb41-4"><a href=""></a>New area<span class="op">:</span> <span class="fl">28.26</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div></div>
<aside class="notes">
<p>
Here’s the answer. <pause> First, radius is 5.0, and we compute its area: 3.14 times 5 times 5 equals 78.5. We print “Radius: 5” and “Area: 78.5”. <pause> Then we create newRadius as 3.0 and call calculateArea directly in the cout statement. The function computes 3.14 times 3 times 3, which is 28.26, and that value gets printed immediately. <pause> Did you get it right? If so, excellent! If not, go back and trace through step by step. This kind of code tracing is an essential skill that will help you debug and understand programs throughout your career.
</pause></pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>
<section id="code-this-pizza-order-calculator" class="title-slide slide level1 center">
<h1>Code This: Pizza Order Calculator</h1>
<p><strong>Estimated Time:</strong> 20 minutes</p>
<aside class="notes">
<p>
<pause> Now it’s time for you to practice! This is a hands-on coding exercise where you’ll apply everything we’ve learned today to build a complete program from scratch.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="problem-description" class="slide level2">
<h2>Problem Description</h2>
<p>Write a program that calculates the cost of a pizza order. Your program should use multiple functions to break down the calculation into logical steps.</p>
<aside class="notes">
<p>
You’re going to build a pizza order calculator - a practical program that demonstrates everything we’ve covered: function prototypes, void functions, functions with parameters, and functions that return values. The key is breaking the problem down into logical steps, with each step implemented as a function. This is exactly how professional programmers approach problems - divide and conquer.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="requirements" class="slide level2">
<h2>Requirements</h2>
<p>Your program must include the following functions:</p>
<ol type="1">
<li><strong>calculatePizzaCost</strong> - Takes the pizza size (small, medium, or large) as a character (‘S’, ‘M’, or ‘L’) and returns the base cost as a double.
<ul>
<li>Small: $8.99</li>
<li>Medium: $12.99</li>
<li>Large: $16.99</li>
</ul></li>
<li><strong>calculateToppingsCost</strong> - Takes the number of toppings as an integer and returns the total topping cost as a double.
<ul>
<li>Each topping costs $1.50</li>
</ul></li>
</ol>
<aside class="notes">
<p>
Let’s break down the requirements. <pause> First, you need calculatePizzaCost - this takes a char parameter for size and returns a double. Use an if statement or switch to determine the price based on size. <pause> Second, calculateToppingsCost takes an int for number of toppings and returns the total cost. This is a simple multiplication: number times 1.50.
</pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="requirements-cont" class="slide level2">
<h2>Requirements (cont)</h2>
<ol start="3" type="1">
<li><p><strong>calculateTotal</strong> - Takes the pizza cost and toppings cost as parameters and returns the final total as a double.</p></li>
<li><p><strong>displayReceipt</strong> - A void function that takes the pizza size (char), number of toppings (int), and total cost (double) as parameters and displays a formatted receipt.</p></li>
</ol>
<aside class="notes">
<p>
Third, calculateTotal takes two parameters - pizza cost and toppings cost - and returns their sum. Simple but demonstrates passing multiple parameters and returning a result. <pause> Finally, displayReceipt is a void function that takes three pieces of information and displays a nicely formatted receipt. This demonstrates void functions and working with multiple parameter types.
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="sample-output" class="slide level2">
<h2>Sample Output</h2>
<p>For a medium pizza with 3 toppings, your program should display:</p>
<pre><code>Pizza Order Receipt
-------------------
Size: M
Toppings: 3
-------------------
Total: $17.49</code></pre>
<aside class="notes">
<p>
Here’s what your output should look like. Notice the formatting - nice clean lines separating sections, and the dollar amount formatted with two decimal places. Use the iomanip library’s fixed and setprecision for proper dollar formatting. Your challenge is to make your output match this format exactly.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="your-task" class="slide level2">
<h2>Your Task</h2>
<ol type="1">
<li>Write function prototypes for all four functions</li>
<li>Implement the main() function to:
<ul>
<li>Create variables for pizza size (‘M’) and number of toppings (3)</li>
<li>Call the functions in the correct order</li>
<li>Display the receipt</li>
</ul></li>
<li>Implement all four function definitions below main()</li>
</ol>
<aside class="notes">
<p>
<slow down=""> Here’s your implementation strategy. First, write all four prototypes at the top of your file - this declares what functions exist. <pause> Second, write main: create variables for size and toppings, then call your functions in the logical order - calculate pizza cost, calculate toppings cost, calculate total, display receipt. Think through what order makes sense. <pause> Third, implement each function below main. Start with the simplest ones and work up to the more complex ones. Test as you go - get one function working before moving to the next. This incremental approach will help you avoid bugs and make debugging easier.
</pause></pause></slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="starter-code-structure" class="slide level2">
<h2>Starter Code Structure</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb43"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb43-1"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb43-2"><a href=""></a><span class="pp">#include </span><span class="im">&lt;iomanip&gt;</span></span>
<span id="cb43-3"><a href=""></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb43-4"><a href=""></a></span>
<span id="cb43-5"><a href=""></a><span class="co">// Write your function prototypes here</span></span>
<span id="cb43-6"><a href=""></a></span>
<span id="cb43-7"><a href=""></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb43-8"><a href=""></a>    <span class="co">// Your code here</span></span>
<span id="cb43-9"><a href=""></a></span>
<span id="cb43-10"><a href=""></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-11"><a href=""></a><span class="op">}</span></span>
<span id="cb43-12"><a href=""></a></span>
<span id="cb43-13"><a href=""></a><span class="co">// Write your function definitions here</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<aside class="notes">
<p>
Here’s your starter template. Notice we’ve included iomanip for formatting. Your job is to fill in the prototypes, implement main, and write all four function definitions. Remember the pattern: prototypes declare what exists, main coordinates the workflow, definitions provide the implementations.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="tips" class="slide level2">
<h2>Tips</h2>
<ul>
<li>Remember to use function prototypes before main()</li>
<li>The displayReceipt function should use cout with proper formatting</li>
<li>Use setprecision(2) and fixed for dollar amounts</li>
<li>Make sure your function calls pass arguments in the correct order</li>
<li>Test with the given values first: size ‘M’ and 3 toppings</li>
</ul>
<aside class="notes">
<p>
Some tips to help you succeed: <pause> Don’t forget those prototypes - they must come before main. <pause> Use fixed and setprecision(2) to format dollar amounts correctly. <pause> Pay careful attention to argument order when calling functions - the order must match the parameter order. <pause> Start by testing with the given example - medium pizza with 3 toppings - so you can verify your output matches the expected output. Once that works, try other combinations to make sure your logic is sound. <pause> Take your time, think through the logic, and remember everything we’ve learned today. You’ve got this!
</pause></pause></pause></pause></pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="challenge-optional---if-you-finish-early" class="slide level2">
<h2>Challenge (Optional - if you finish early)</h2>
<p>Modify your program to ask the user for their pizza size and number of toppings using cin, then display the receipt with their choices.</p>
<aside class="notes">
<p>
If you finish early and want an extra challenge, modify your program to read the pizza size and number of toppings from the user using cin. This adds interactivity to your program. You’ll need to add input validation to make sure they enter valid sizes and non-negative topping counts. This optional challenge will give you practice with user input and validation logic.
</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section id="key-takaways" class="title-slide slide level1 center">
<h1>Key Takaways</h1>
<ol type="1">
<li><strong>Function-Centric Architecture</strong>. A program design approach organizing code around functions as primary building blocks, separating data and behavior through a top-down design where main problems are broken into smaller sub-problems implemented as functions.</li>
<li><strong>Void Functions</strong>. Functions declared with void return type perform actions without returning values, used to organize code, avoid repetition, and improve readability through descriptive function names that act as labels for code blocks.</li>
<li><strong>Passing Data and Function Prototypes</strong>. Functions accept input through parameters and return output via return statements, with function prototypes declared before main to enable forward references and organize code with definitions below main.</li>
</ol>
<aside class="notes">
<p>
<slow down=""> Let’s wrap up with the key takeaways from today’s lecture. <pause> First, function-centric architecture is a design philosophy where functions are your primary organizational tool. You break big problems into smaller sub-problems, implement each as a function, and separate data from the operations on that data. This creates code that’s modular, maintainable, and understandable. <pause> Second, void functions are your tool for organizing code that performs actions without computing return values. They help you avoid code duplication, give meaningful names to code blocks, and keep your main logic clean and readable. <pause> Third, by combining parameters and return values, you create flexible, reusable functions. Parameters bring data in, return values send results back. Function prototypes let you organize your code with declarations at the top and implementations below main. <pause> These three concepts form the foundation of structured, function-based programming. Master them and you’ll be able to write clean, professional, maintainable code.
</pause></pause></pause></pause></slow></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="next-time" class="title-slide slide level1 center">
<h1>Next Time</h1>
<ul>
<li>Local and global variables</li>
<li>Memory and functions</li>
</ul>
<aside class="notes">
<p>
Next time, we’ll dive deeper into how functions work with variables and memory. We’ll explore the difference between local and global variables, understand variable scope in detail, and see how memory is managed when functions are called. This will complete your understanding of how functions really work under the hood. <pause> Great work today everyone! Make sure to practice with the pizza calculator exercise - hands-on coding is how these concepts really sink in. See you next time!
</pause></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>

</section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">
<p>CISP 360 · Fowler</p>
</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/notes/notes.js"></script>
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/search/search.js"></script>
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="p360_lecture_04.01_combined_files/libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': false,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'h.v',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 5.0e-2,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
          const outerScaffold = trigger.parentElement.cloneNode(true);
          const codeEl = outerScaffold.querySelector('code');
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp('/' + window.location.host + '/');
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    <script>
    window.Reveal.on('ready', event => {
      Reveal.configure({
        keyboard: {
          34: 'down',   // Forward button
          33: 'up',     // Back button
          116: 'right',  // Start/Play button
          190: 'left'    // Black Screen button
          79: null        // Disable 'O' for overview
        }
      });
    });
    </script>
    

</body></html>